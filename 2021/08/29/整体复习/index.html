<!DOCTYPE HTML>
<html lang="zh-CN">



<head>
    <meta charset="utf-8">
    <meta name="keywords" content="瀚77的博客">
    <meta name="description" content="本网站是个人兴趣爱好，总结分享经验，记录生活点滴的平台，希望在以后的学习旅途中，走出自己的风景。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>瀚77的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="瀚77的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>








<body>

    

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">瀚77的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">瀚77的博客</div>
        <div class="logo-desc">
            
            本网站是个人兴趣爱好，总结分享经验，记录生活点滴的平台，希望在以后的学习旅途中，走出自己的风景。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0/" class="post-category">
                                整体复习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-08-29
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-10-02
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    68.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    256 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="String、StringBuffer、StringBuilder三者的异同？"><a href="#String、StringBuffer、StringBuilder三者的异同？" class="headerlink" title="String、StringBuffer、StringBuilder三者的异同？"></a>String、StringBuffer、StringBuilder三者的异同？</h2><ul>
<li>String:不可变的字符序列；底层使用char[]存储</li>
<li>StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</li>
<li>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</li>
<li>都是用final修饰的类</li>
</ul>
<p>为什么string是不可变的？</p>
<p>·    在string常量池中，可能有很多的引用指向同一个字符串，如果string类是可变的，那么一个引用修改此值，其他的引用也都跟着变化，存在一个客户的操作影响到其他客户情况。所以将他设置成不可变的，所谓不可变，就是如果一个客户修改此字符串，那么将会在重新创建一个string对象，不会对原来的值产生影响。</p>
<p>​    还有就是我认为不可变的另一个原因可能是由于  hashmap，因为开发的时候很多时候都使用字符串来作为hashmap 的key，然而对于hashmap的键值来说，不可变性是非常的重要，以便用它们检索存储在 HashMap 中的值对象。如果在插入后修改了 String 的内容，可变的 String 将在插入和检索时生成两个不同的哈希码，可能会丢失 Map 中的值对象。</p>
<p>为什么string类是final的？</p>
<p>​    将string类设置成final的，就没有人可以通过扩展和覆盖行为来破坏 String 类的不变性、缓存、散列值的计算等。</p>
<h2 id="关于char的三元运算符"><a href="#关于char的三元运算符" class="headerlink" title="关于char的三元运算符"></a>关于char的三元运算符</h2><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> x <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">?</span> x <span class="token operator">:</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//120</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">?</span> <span class="token string">'x'</span> <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//x</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">?</span> <span class="token string">'x'</span> <span class="token operator">:</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//A</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">?</span> <span class="token string">'x'</span> <span class="token operator">:</span> <span class="token number">65536</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//120</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/*
 * 如果其中有一个是变量，按照自动类型转换规则处理成一致的类型；
 * 如果都是常量:
 *      如果一个是char，如果另一个是[0~65535]之间的整数按char处理；
 *       如果一个是char，另一个是其他，按照自动类型转换规则处理成一致的类型；
 */</span>
</code></pre>
<h2 id="接口和类在设计层面的区别"><a href="#接口和类在设计层面的区别" class="headerlink" title="接口和类在设计层面的区别"></a>接口和类在设计层面的区别</h2><p>​    ①<strong>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</strong>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将飞行设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>【补充：抽象类可以也继承具体的类】</p>
<p>​    ② <strong>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计</strong>。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
<h2 id="BIO、NIO、AIO有什么区别"><a href="#BIO、NIO、AIO有什么区别" class="headerlink" title="BIO、NIO、AIO有什么区别"></a>BIO、NIO、AIO有什么区别</h2><p> BIO：Bolck IO ，同步阻塞式IO，就是传统的IO，特点是模式简单，使用方便，并发处理能力低</p>
<p> NIO：New IO，同步非阻塞式IO，是传统IO的升级，客户端和服务器通过Channel通讯，实现了多了复用</p>
<p> AIO：Asynchronous IO，是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制</p>
<h2 id="File的常用方法"><a href="#File的常用方法" class="headerlink" title="File的常用方法"></a>File的常用方法</h2><p>Files.exists()：检测文件路径是否存在</p>
<p>Files.createFile()：创建文件</p>
<p>Files.createDirectory()：创建文件夹</p>
<p>Files.delete()：删除一个文件或者目录</p>
<p>Files.copy()：复制文件</p>
<p>Files.move()：移动文件</p>
<p>Files.size()：查看文件个数</p>
<p>Files.read()：读取文件</p>
<p>Files.write()：写入文件</p>
<h2 id="Array与ArrayList有什么不一样"><a href="#Array与ArrayList有什么不一样" class="headerlink" title="Array与ArrayList有什么不一样"></a>Array与ArrayList有什么不一样</h2><p>​    Array和ArrayList都是用来存储数据的集合。ArrayList底层是使用数组实现的，但是ArrayList对数组进行了封装和功能的扩展</p>
<h2 id="JDBC操作的步骤"><a href="#JDBC操作的步骤" class="headerlink" title="JDBC操作的步骤"></a>JDBC操作的步骤</h2><ul>
<li>加载数据库驱动类</li>
<li>打开数据库连接</li>
<li>执行sql语句</li>
<li>处理返回结果</li>
<li>关闭资源</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**将数据库连接需要的4个基本信息声明在配置文件中，通过读取配置文件的方式，获取连接
 * 好处
 * 1.实现数据与代码的分离。实现了解耦
 * 2.如果需要修改配置文件信息，可以避免程序重新打包。
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testConnection5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//读取配置文件中的信息</span>
   InputStream is <span class="token operator">=</span>ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>

    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String driverClass <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driverClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//2.加载驱动</span>
    Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driverClass<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//3.获取连接</span>
    Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#键值对中间不要加空格</span>
<span class="token attr-name">user</span><span class="token punctuation">=</span><span class="token attr-value">root</span>
<span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">172161</span>
<span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/test</span>
<span class="token attr-name">driverClass</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span>
</code></pre>
<h2 id="怎么在JDBC内调用一个存储过程"><a href="#怎么在JDBC内调用一个存储过程" class="headerlink" title="怎么在JDBC内调用一个存储过程"></a>怎么在JDBC内调用一个存储过程</h2><p>​    使用 callableStatement 类</p>
<pre class=" language-mysql"><code class="language-mysql">mysql> CREATE DATABASE EMP $$

mysql> DROP PROCEDURE IF EXISTS `EMP`.`getEmpName` $$

mysql> CREATE PROCEDURE `EMP`.`getEmpName`
    ->    (IN EMP_ID INT, OUT EMP_FIRST VARCHAR(255))
    -> BEGIN
    ->    SELECT first INTO EMP_FIRST
    ->    FROM Employees
    ->    WHERE ID = EMP_ID;
    -> END $$
mysql> DELIMITER ;
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ProcedureTest<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>CallableStatement<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>SQLException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>Types<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>dbcp<span class="token punctuation">.</span>BasicDataSource<span class="token punctuation">;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdbcConnectedPro</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Connection connection<span class="token operator">=</span>null<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> CallableStatement callableStatement <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//private static ResultSet resultSet = null;//结果集</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String sql <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 创建connection对象
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//创建dataSource</span>
        BasicDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//加载数据库驱动</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setDriverClassName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//设置用户名和密码</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            connection<span class="token operator">=</span>dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> connection<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 基于存储过程实例化CallableStatement对象
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> CallableStatement <span class="token function">getStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//String sql = "";//&amp;#123;call getEmpName (?, ?)&amp;#125;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            callableStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareCall</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> callableStatement<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//关闭资源</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> callableStatement<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                callableStatement<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> connection<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        sql <span class="token operator">=</span> <span class="token string">"&amp;#123;call getEmpName (?, ?)&amp;#125;"</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">getStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            callableStatement<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            callableStatement<span class="token punctuation">.</span><span class="token function">registerOutParameter</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> Types<span class="token punctuation">.</span>VARCHAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
            callableStatement<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行</span>
            <span class="token keyword">int</span> result <span class="token operator">=</span> callableStatement<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"返回结果为"</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="使用数据库连接池有有什么好处"><a href="#使用数据库连接池有有什么好处" class="headerlink" title="使用数据库连接池有有什么好处"></a>使用数据库连接池有有什么好处</h2><p>​    数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。</p>
<h2 id="GC是什么-为什么要有GC"><a href="#GC是什么-为什么要有GC" class="headerlink" title="GC是什么? 为什么要有GC"></a>GC是什么? 为什么要有GC</h2><p>​        答：GC是垃圾收集的意思（Garbage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法</p>
<p>​    垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</p>
<p>​    如果对象的引用被置为null，垃圾收集器在下一个垃圾回调周期中才会释放其占用的内存，不会立即释放对象占用的内存</p>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p><strong>进程</strong>是系统进行资源分配的独立单位，<strong>线程</strong>是CPU调度和分派的基本单位。</p>
<p><strong>进程和线程的关系</strong></p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，并且至少有一个线程。</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li>
<li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</li>
<li>线程是指进程内的一个执行单元，也是进程内的可调度实体</li>
</ul>
<p><strong>线程和进程的区别</strong></p>
<ul>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>
<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行</li>
<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源</li>
<li>系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销，但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮性高，但是在进程切换时，耗费的资源较大，效率要差些。</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>​        OverLoad为重载，Override为重写，方法的重写和重载就是java多态性的不同表现，并且重写是父类和子类中的多态性的一种表现。</p>
<p>​        如果在子类中定义某方法与其父类有相同的名称和参数，就说该方法被重写了，子类的对象使用这个方法时，调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。</p>
<p>​       如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或者有不用的参数类型，则称为方法重载</p>
<h2 id="如果对象的引用被值为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被值为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被值为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被值为null，垃圾收集器是否会立即释放对象占用的内存？</h2><p>不会立即被回收，但是在下一个垃圾回收周期中这个对象将是可被回收的。</p>
<h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><p>类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例</p>
<h2 id="Char类型能不能转成int类型？"><a href="#Char类型能不能转成int类型？" class="headerlink" title="Char类型能不能转成int类型？"></a>Char类型能不能转成int类型？</h2><p>​    Char在java中也是比较特殊的类型，int值从1开始，一共有2的16次方个数据；Char &lt; int &lt; long &lt; float &lt; double；Char类型可以隐式转换成int、double类型，但是不能隐式转换成string；如果Char类型转成byte，short类型的时候，需要强转。Char类型的默认值为 ‘ ‘ 。</p>
<h2 id="Java中有没有指针？"><a href="#Java中有没有指针？" class="headerlink" title="Java中有没有指针？"></a>Java中有没有指针？</h2><p>有，但是被隐藏了，开发人员无法直接操作指针，由jvm来操作指针</p>
<h2 id="Java中是值传递还是引用传递"><a href="#Java中是值传递还是引用传递" class="headerlink" title="Java中是值传递还是引用传递"></a>Java中是值传递还是引用传递</h2><p><strong>是值传递。</strong>Java 语言的参数传递只有值传递。对于基本数据类型，传递的是值的副本，而不是值本身；对于对象类型作为参数被传递到方法中时，参数的值就是该对象的引用的一个副本。指向同一个对象，对象的内容可以在被调用的方法内改变，但对象的引用(不是引用的副本) 是永远不会改变的。</p>
<h2 id="普通内部类与静态内部类的区别"><a href="#普通内部类与静态内部类的区别" class="headerlink" title="普通内部类与静态内部类的区别"></a>普通内部类与静态内部类的区别</h2><p>​    静态内部类是独立于外部类的存在，在静态内部类中无法直接访问外部类中的非静态变量和方法，如果要访问的话，必须new一个外部类的对象，使用new出来的对象进行访问。但是可以直接访问静态的变量，调用静态的方法。</p>
<p>​    普通内部类作为外部类的一个成员，在普通内部类中可以直接访问外部类属性，调用外部类的方法(静态和非静态都可以)。普通类里面不能有静态属性和方法</p>
<p>​    如果外部类要调用内部类的普通属性和方法，无论是不是静态的，必须创建一个内部类的对象，使用该对象访问属性或者调用方法。如果是静态内部类的静态属性和方法，则可以直接通过类调用。</p>
<p>​    如果其他类要访问普通内部类的属性和方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，其他类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性</p>
<p>​    如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类的对象即可。</p>
<h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><p>​    static修饰方法是静态方法，表示该方法是当前类的，静态方法不能被重写，<strong>子类可以直接调用父类的静态方法，但实现类不能调用接口的静态方法</strong>，在static中不能使用this和super关键字。</p>
<p>​    Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。</p>
<h2 id="java中的继承是单继承还是多继承"><a href="#java中的继承是单继承还是多继承" class="headerlink" title="java中的继承是单继承还是多继承"></a>java中的继承是单继承还是多继承</h2><p>java中既有单继承，又有多继承，对于java类来说是单继承，对于接口来说是多继承</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>​    如果父类中没有无参构造器，子类中的构造器又没有显式调用父类中的有参构造器，则会报错，因为子类默认调用父类的无参构造器</p>
<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>​    <strong>接口就是某个事物对外提供的一些功能的声明</strong>，是一种特殊的java类</p>
<p>​       1) 接口和接口内方法都是隐式抽象的，<strong>不需要加</strong>abstract关键字</p>
<p>　　2) 接口可以是<strong>public</strong>修饰<strong>或者默认缺省(default)</strong></p>
<p>　　3) 接口中的方法默认并且只能是<strong>public</strong></p>
<p>　　4)接口中定义的变量默认并且只能是<strong>public static final</strong> 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值</p>
<p>　　5) 有用<strong>private</strong>修饰的接口，属于类的内嵌接口，但是私有接口的方法和变量也必须是<strong>public</strong>修饰的</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>程序在执行过程中，一旦出现异常，就会在异常出生成一个对应异常类的对象，并将此对象抛出，由try-catch-finally或者throws捕获。</p>
<p>如果父类的方法没有抛异常，则子类重写的方法是不能抛异常的，只能是try-catch。</p>
<p><strong>常见的编译时异常：</strong></p>
<p>​    NoSuchMethodException：反射找方法时找不到会报此异常。</p>
<p>​     FileNotFoundException：加载配置文件找不到，属于IO异常的子类</p>
<p>​    IOException</p>
<p>​    SQLException</p>
<p>​    InterruptedException：线程中调用Thread.sleep()是会捕获这个异常</p>
<p>​    InstantiationException：clazz.newInstance();时抛出的</p>
<p>​    ClassNotFoundException：类为发现异常</p>
<p>常见的运行时异常：</p>
<p>​    NoSuchElementException： iterator.next()的时候如果没有下一个元素时报此异常</p>
<p>​    ArrayIndexOutOfBoundsException</p>
<p>​    IllegalArgumentException</p>
<p>​    NoSuchElementException</p>
<p>​    NotSerializeableException：类没有实现序列化接口</p>
<p>​    NumberFormatException ： Integer.parseInt(string); 这里的string如果不是纯数字的字符串就会报错</p>
<p>​    ConcurrentModificationException： java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓fail-fast策略</p>
<p>   IllegalThreadStateException ： 同一个线程启动了两次</p>
<h2 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h2><p>Error 和 Exception都是java错误处理机制的一部分，都继承了Throwable类。</p>
<p>​    Exception表示异常，异常可以通过程序来捕捉或者优化程序来避免</p>
<p>​    Error 表示的是系统错误，不能通过程序来进行错误处理</p>
<h2 id="使用Log4j对程序有影响吗"><a href="#使用Log4j对程序有影响吗" class="headerlink" title="使用Log4j对程序有影响吗"></a>使用Log4j对程序有影响吗</h2><p>​    有，log4j是用来日志记录的，记录一些关 键敏感的信息，通常会将日志记录到本地文件或者数据库中。记录在本地文件中，会有频繁的io操作，会耗费一些系统资源。记录在数据库中，会频繁地操作数据库表，对系统性能也有一定的影响。但是为了程序安全以及数据的恢复或者bug的跟踪，这点资源消耗是可以承受的。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>​        <strong>对象序列化机制</strong>允许把内存中的Java对象转换成二进制流(使用ObjectOutputStream)，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以反序列化为原来的Java对象(使用ObjectInputStream)</p>
<p>​        序列化的好处在于可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原</p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>1&gt;  transient的作用及使用方法：<br>     java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加    关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中；<br>2&gt; transient 使用小结<br>     1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p>
<p>​     2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p>
<p>​     3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p>
<p>3&gt; 被transient关键字修饰的变量也是能被序列化<br>     若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手动指定所要序列化的变量，这与是否被transient修饰无关。</p>
<h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><ul>
<li><p>集合就是一个放数据的容器，准确的说是放数据对象引用的容器</p>
</li>
<li><p><strong>集合类存放的都是对象的引用，而不是对象本身</strong></p>
</li>
<li><p>常见的有list、set、map</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>集合用于存储对象的容器，对象是用来封装数据的，对象多了也是需要集中式存储管理。</li>
<li>所以集合是可变长度的，因为对象的大小不确定。</li>
</ul>
<h2 id="集合与数组的比较"><a href="#集合与数组的比较" class="headerlink" title="集合与数组的比较"></a>集合与数组的比较</h2><ul>
<li>数组是固定长度的；集合是可变长度的。</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型</li>
<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同的数据类型</li>
</ul>
<h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ul>
<li>容量自增长</li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序的速度和质量</li>
<li>可以方便的扩展和改写集合，提高代码复用性和可操作性</li>
</ul>
<h2 id="Java中使用Collections-的最佳实践"><a href="#Java中使用Collections-的最佳实践" class="headerlink" title="Java中使用Collections 的最佳实践"></a>Java中使用Collections 的最佳实践</h2><ul>
<li>根据开发场景使用合适的集合类</li>
<li>优先使用并发集合，而不是对集合进行同步，并发集合可以提供更好的扩展性</li>
<li>使用迭代器来遍历集合</li>
<li>使用集合的时候加上泛型</li>
</ul>
<h2 id="常用的集合类有哪些"><a href="#常用的集合类有哪些" class="headerlink" title="常用的集合类有哪些"></a>常用的集合类有哪些</h2><p>Collection</p>
<ul>
<li><p>List：有序，可重复</p>
<ul>
<li>ArrayList：数组结构，非线程安全</li>
<li>LinkedList：双向循环链表结构，非线程安全</li>
<li>Vector：数组结构，线程安全</li>
</ul>
</li>
<li><p>Set：无序，唯一</p>
<ul>
<li>HashSet：哈希表</li>
<li>TreeSet：红黑树</li>
<li>LinkedHashSet：哈希表和链表</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>HashMap</li>
<li>TreeMap</li>
<li>HashTable</li>
<li>ConcurrentHashMap</li>
<li>Properties</li>
</ul>
</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​    ArrayList 是一个动态数组，实现了 List 接口以及 list相关的所有方法，它允许所有元素的插入，包括 null。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认容量的大小</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//空数组常量</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//默认的空数组常量</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//存放元素的数组</span>
<span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//数组的最大上限</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>构造方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>


<span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>默认情况下，elementData 是一个大小为 0 的空数组，当我们指定了初始大小的时候，elementData 的初始大小就变成了所指定的初始大小。</p>
<ul>
<li>get方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size<span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

E <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    因为 ArrayList 是采用数组结构来存储的，所以它的 get 方法非常简单，先是判断一下有没有越界，之后就可以直接通过数组下标来获取元素了，所以 get 的时间复杂度是 O(1)。 </p>
<ul>
<li>add方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>
   elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>
   System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
                    size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
   elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
   size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

   <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   modCount<span class="token operator">++</span><span class="token punctuation">;</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    在插入元素之前，它会先检查是否需要扩容，然后再把元素添加到数组中最后一个元素的后面。在 ensureCapacityInternal 方法中，我们可以看见，如果当 elementData 为空数组时，它会使用默认的大小去扩容。所以说，通过无参构造方法来创建 ArrayList 时，它的大小其实是为 0 的，只有在使用到的时候，才会通过 grow 方法去创建一个大小为 10 的数组。</p>
<ul>
<li>set方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

   E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
   elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
   <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>set 方法的作用是把下标为 index 的元素替换成 element</p>
<ul>
<li>remove()方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>
                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>

    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>grow方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>
    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    grow 方法是在数组进行扩容的时候用到的，从中我们可以看见，ArrayList 每次扩容都是扩 1.5 倍，然后调用 Arrays 类的 copyOf 方法，把元素重新拷贝到一个新的数组中去。</p>
<ul>
<li>size方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> size<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>直接返回 size 的值</p>
<ul>
<li>indexOf方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>indexOf 方法的作用是返回第一个等于给定元素的值的下标。它是通过遍历比较数组中每个元素的值来查找的，所以它的时间复杂度是 O(n)。</p>
<ul>
<li>lastIndexOf方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    lastIndexOf 的原理跟 indexOf 一样，从后往前找起</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>​    很多方法都跟 ArrayList 一样，只是多加了个 synchronized 来保证线程安全</p>
<p>Vector 比 ArrayList 多了一个属性：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">;</span>
</code></pre>
<p>​    这个属性是在扩容的时候用到的，它表示每次扩容只扩 capacityIncrement 个空间就足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//三个构造方法</span>
<span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>
                                         initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>capacityIncrement <span class="token operator">=</span> capacityIncrement<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>Vector 的默认大小也是 10，不过它在初始化的时候就已经创建了数组。</p>
<ul>
<li>grow方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// overflow-conscious code</span>
    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>capacityIncrement <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                     capacityIncrement <span class="token operator">:</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​        newCapacity 默认情况下是<strong>两倍</strong>的 oldCapacity，而当指定了 capacityIncrement 的值之后，newCapacity 变成了</p>
<p>oldCapacity+capacityIncrement。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>​    LinkedList 是通过一个双向链表来实现的，它允许插入所有类型的元素，包括 null，同时它是线程不同步的。</p>
<p>​    双向链表每个结点除了数据域之外，还有一个前指针和后指针，分别指向前驱结点和后继结点（如果有前驱/后继的话）。另外，双向链表还有一个 first 指针，指向头节点，和 last 指针，指向尾节点。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//链表的节点个数</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//指向头节点的指针</span>
<span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//指向尾节点的指针</span>
<span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span>
</code></pre>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>哈希表是基于 Map 接口的实现的，它允许 null 值和 null 键，它不是线程同步的，同时也不保证有序</p>
<p>如果涉及到大量的遍历操作的话，就尽量不要把 capacity 设置得太高（或 load factor 设置得太低），否则会严重降低遍历的效率</p>
<p>​    影响 HashMap 性能的两个重要参数：“initial capacity”（初始化容量）和”load factor“（负载因子）。简单来说，容量就是哈希表桶的个数，负载因子就是键值对个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap 就会进行 rehash操作来进行扩容。</p>
<p>​    哈希表是一个数组，经常把数组中的每一个节点称为一个桶，哈希表中的每一个节点都用来存储一个键值对。在插入元素时，如果发生冲突的话，就会通过链表的形式来解决冲突。因为一个桶上可能存在多个键值对，所以在查找的时候，会先通过key的哈希值定位到桶，在遍历桶上所有的键值对，找出key相等的键值对，从而来获取value。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认的初始容量为 16</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//最大的容量上限为 2^30</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//默认的负载因子为 0.75</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>


经过计算，在 hash 函数设计合理的情况下，发生 hash 碰撞 <span class="token number">8</span> 次的几率为百万分之 <span class="token number">6</span>，概率说话。因为 <span class="token number">8</span> 够用了，至于为什么转回来是 <span class="token number">6</span>，如果一个HashMap不停的插入、删除元素，链表个数在<span class="token number">8</span>左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。如果一个桶上的冲突很严重的话，是会导致哈希表的效率降低至 O（n），而通过红黑树的方式，可以把效率改进至 O（logn）。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式
<span class="token comment" spellcheck="true">//变成树型结构的临界值为 8</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//恢复链式结构的临界值为 6，当扩容时，桶中元素个数小于这个值就会把树形的桶元素 还原（切分）为链表结构</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>


<span class="token comment" spellcheck="true">//哈希表</span>
<span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//哈希表中键值对的个数</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//哈希表被修改的次数</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//它是通过 capacity*loadfactor 计算出来的，当 size 到达这个值时，就会进行扩容操作</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//负载因子</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
</code></pre>
<p>Node 类的定义，它是 HashMap 中的一个静态内部类，哈希表中的每一个节点都是 Node 类型。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>get方法，里面调用的是getNode()</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//如果哈希表不为空， &amp;&amp; key对应的桶上不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
       
       <span class="token comment" spellcheck="true">//是否直接命中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> first<span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//判断是否有后续节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
           <span class="token comment" spellcheck="true">//如果桶采用的是红黑树的结构，则用红黑树的get方法获取</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
           
           <span class="token comment" spellcheck="true">//如果不是，通过循环的方法判断链中是否存在key</span>
            <span class="token keyword">do</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>总结：</p>
<ul>
<li>通过hash值获取该key映射到的桶</li>
<li>若桶上的第一个key就是要查找的key，则直接命中</li>
<li>若桶上不是要查找的结点，则查看后续节点<ul>
<li>如果后续节点是树节点，通过调用树的方法查找该key</li>
<li>如果后续节点是红黑树，则通过循环遍历链查找该key</li>
</ul>
</li>
</ul>
<ul>
<li>put方法，内部调用putVal()。</li>
</ul>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//如果哈希表为空，则先创建一个哈希表，说明hashmap也是在用的时候才创建</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//如果当前桶没有碰撞冲突，则直接把键值对插入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
           
           <span class="token comment" spellcheck="true">//如果桶上节点的 key 与当前 key 重复，那么就把这个key键的值替换成新的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
           <span class="token comment" spellcheck="true">//如果是采用红黑树的方式处理冲突，则通过红黑树的 putTreeVal 方法去插入这个键值对</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment" spellcheck="true">//否则就是传统的链式结构</span>
            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
               <span class="token comment" spellcheck="true">//循环遍历，判断链中是否有重复的key</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                   <span class="token comment" spellcheck="true">//到了链尾还没找到重复的 key，则说明 HashMap 没有包含该键</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                       <span class="token comment" spellcheck="true">//创建一个新的结点插入到尾部</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token comment" spellcheck="true">//如果链的长度大于 TREEIFY_THRESHOLD 这个临界值，调用treeifyBin</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                   <span class="token comment" spellcheck="true">//这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>
                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">//判断是否需要扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>总结：</p>
<ul>
<li>先通过hash值计算出key映射到哪个桶</li>
<li>如果桶上没有冲突，直接插入</li>
<li>如果发生冲突了，需要处理冲突<ul>
<li>如果该桶使用红黑树处理冲突，则调用红黑树的方式插入</li>
<li>否则采用传统的链式方法插入。如果插入之后链的长度达到临界值(桶内的元素达到8并且桶的长度大于64)，则链表转换为红黑树</li>
</ul>
</li>
<li>如果同时存在重复的键，则为该键替换新值。</li>
<li>如果size大于阈值，则进行扩容</li>
</ul>
<p>【处理冲突的方法：rehash 再哈希、链地址法 ，hashMap中用的就是这个、开放定址法、公共溢出区】</p>
<ul>
<li><p>开放定址法：通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位</p>
</li>
<li><p>公共溢出区：为所有冲突的关键字记录建立一个公共的溢出区来存放</p>
</li>
</ul>
<ul>
<li>hash方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token comment" spellcheck="true">//计算存放位置的公式</span>
</code></pre>
<p>n 指的是哈希表的大小，hash 指的是 key 的哈希值，hash是通过下面这个方法计算出来的，采用了二次哈希的方式。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> h<span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    这个 hash 方法先通过 key 的 hashCode 方法获取一个哈希值，再拿这个哈希值与它的高 16 位的哈希值做一个异或操作来得到最后的哈希值，计算过程可以参考下图。为啥要这样做呢？注释中是这样解释的：如果当 n 很小，假设为 64 的话，那么 n-1即为 63（0x111111），这样的值跟 hashCode()直接做与操作，实际上只使用了哈希值的后 6 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210831154924.png"></p>
<p>​      正是因为与的这个操作，决定了 HashMap 的大小只能是 2 的幂次方，因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是 00000000 00000000 00001111。和某散列值做“与”操作，结果就是截取了最低的四位值。</p>
<p>​    即使你在创建 HashMap 的时候指定了初始大小，HashMap 在构建的时候也会调用下面这个方法来调整大小：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
   n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
   n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>
   n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>
   n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>
   n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_C
      APACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    实际作用就是把 cap 变成第一个大于等于 2 的幂次方的数。例如，16 还是 16，13 就会调整为 16，17 就会调整为 32。</p>
<ul>
<li><p>resize方法</p>
<ul>
<li><p>==<strong>当哈希表中的键值对的个数超过 容量*0.75 时进行扩容，不是桶的占用量超过 容量*0.75 进行扩容</strong>==</p>
</li>
<li><p>当哈希表中的条目数超出了加载因子与当前容量的乘积时，<strong>并且要存放的位置已经有元素了（hash碰撞）</strong>，必须满足这两个条件，才要对该哈希表进行 resize 操作，会将容量扩大为原来两倍。通常，默认加载因子是 0.75，这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了冲突几率。</p>
</li>
<li><p>e.hash &amp; (newCap - 1)，计算扩容后的存放位置，只有两种可能：位置不变或索引+旧容量大小</p>
<p>因为由于扩容是扩大为原数组大小的 2 倍，用于计算数组位置的掩码仅仅只是高位多了一个 1，扩容前长度为 16，用于计算(n-1) &amp; hash 的二进制 n-1 为 0000 1111，扩容为 32 后的二进制就高位多了 1，为 0001 1111。<br>因为是&amp; 运算，1 和任何数 &amp; 都是它本身，那就分二种情况，如下图：原数据 hashcode 高位第 4 位为 0 和高位为 1 的情况；第四位高位为 0，重新 hash 数值不变，第四位为 1，重新 hash 数值比原来大 16（旧数组的容量）<br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210831201940.png"></p>
</li>
</ul>
</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//计算扩容后的大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//如果当前容量超过最大容量，则无法进行扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//没超过最大容量并且oldCap大于默认值16则扩容为原来的两倍</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
                 oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
       
       <span class="token comment" spellcheck="true">//计算新的阈值</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
   
   <span class="token comment" spellcheck="true">//创建新的哈希表</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
       
       <span class="token comment" spellcheck="true">//遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
               <span class="token comment" spellcheck="true">//如果桶上只有一个键值对，则直接插入</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// preserve order</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="头插法和尾插法的比较"><a href="#头插法和尾插法的比较" class="headerlink" title="头插法和尾插法的比较"></a>头插法和尾插法的比较</h2><p>​    因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；<br>​    A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><pre><code>1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；

3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

hashCode()的作用
    Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。主要是针对HashSet和Map集合类型，比如我们在向HashSet集合里边添加新元素的时候，由于set集合里边不允许元素重复，所以我们在插入新元素之前需要先判断插入元素是否存在，首先根据hashCode()方法得到该对象的hashCode值，如果集合里边不存在该值，可以直接插入进去。如果已经存在，则需要再次通过equals()来比较，这样的话可以提升效率。

重写equals()方法为什么要同时重写hashcode()方法？
    重写equals()方法同时重写hashcode()方法，就是为了保证当两个对象通过equals()方法比较相等时，那么他们的hashCode值也一定要保证相等。
    
hashCode()里面为什么要乘以31？
目的是为了减少冲突，因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高
31只占用5bits，相乘造成数据溢出的概率较小
31可以由 i*31 == (i&lt;&lt;5)-1来表示，可以提高算法效率
31是一个素数，和一个数相乘之后的结果只能被1,素数本身和被乘数整除，也是为了减少冲突
</code></pre>
<h2 id="java集合的快速失败机制-“fail-fast”"><a href="#java集合的快速失败机制-“fail-fast”" class="headerlink" title="java集合的快速失败机制 “fail-fast”"></a>java集合的快速失败机制 “fail-fast”</h2><ul>
<li><p> fail-fast” 是java集合的一种错误检测机制，如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略</p>
</li>
<li><p>在 HashMap 的 API 中指出：</p>
<p>​    在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
</li>
<li><p>解决办法就是让集合成为线程安全的</p>
</li>
<li><p>产生原因：</p>
<p>​    迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量，集合在被遍历期间如果内容发生变化，就会改变modCount的值，每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历，否则就抛出ConcurrentModificationException异常</p>
</li>
</ul>
<h2 id="怎么确保一个集合不被修改"><a href="#怎么确保一个集合不被修改" class="headerlink" title="怎么确保一个集合不被修改"></a>怎么确保一个集合不被修改</h2><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> collection <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableCollection</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
collection<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>抛出  java.lang.UnsupportedOperationException 异常</p>
<h2 id="什么是-Iterator迭代器"><a href="#什么是-Iterator迭代器" class="headerlink" title="什么是 Iterator迭代器"></a>什么是 Iterator迭代器</h2><p>​    Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包括了可以返回迭代器实例的迭代方法。迭代器可以在迭代过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object obj)删除，可以通过迭代器的remove()方法删除</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="遍历一个List的三种方式"><a href="#遍历一个List的三种方式" class="headerlink" title="遍历一个List的三种方式"></a>遍历一个List的三种方式</h2><ul>
<li>for循环，基于计数器，在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止</li>
<li>迭代器遍历，Iterator是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口，java在Collection中支持了Iterator</li>
<li>foreach循环遍历，内部也是采用了Iterator的方式实现，使用时不需要显示声明Iterator或计数器，优点是代码简洁，不易出错；缺点是只能简单的遍历，不能在遍历中查找数据集合，例如删除等。</li>
</ul>
<h2 id="ArrayList的优缺点"><a href="#ArrayList的优缺点" class="headerlink" title="ArrayList的优缺点"></a>ArrayList的优缺点</h2><p><strong>优</strong>：</p>
<ul>
<li><p>ArrayList底层以数组实现，是一个种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候很快</p>
</li>
<li><p>ArrayList在顺序添加一个元素的时候非常方便</p>
</li>
</ul>
<p>【RandomAccess接口】RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。也就是说，实现了这个接口的集合是支持 <strong>快速随机访问</strong> 策略的。官网还特意说明了，如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。</p>
<p>​        ArrayList底层的数据结构是Object[]存储，数组在内存分配里，是一段连续的内存空间，譬如分配的内存地址是002，003，004，005四个地址，那么我们如果要随机访问角标为3的数据，只需要访问002+3=005的数据就行了，这就是快速随机访问。</p>
<p>​      LinkedList是链表结构，在内存里是不连续的，相邻的数据之间用指针指向即可。如001&lt;-&gt;003&lt;-&gt;004&lt;-&gt;005.那么此时，我们要访问角标为3的数据，就只能从第一个数据开始依次迭代，找到第4个数据，这就是顺序访问</p>
<p><strong>缺：</strong></p>
<ul>
<li>删除元素的时候需要做一次元素复制，如果复制的元素很多，那么就会耗费性能</li>
<li>插入元素的时候，需要做一次元素复制操作。</li>
<li>ArrayList 比较适合顺序添加，随机访问的场景</li>
</ul>
<h2 id="数组和List之间的转换"><a href="#数组和List之间的转换" class="headerlink" title="数组和List之间的转换"></a>数组和List之间的转换</h2><p>数组  —&gt;  list : Arrays.asList(array)</p>
<p>list —-&gt; 数组：List.toArray()</p>
<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>​        哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制叫做哈希值</p>
<h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><p>​    HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>   在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap 也不例外。HashMap实际上是一个“链表散列”的数据结构，即<strong>数组和链表的结合体</strong></p>
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td>不允许为null</td>
<td>不允许为null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为null</td>
<td>不允许为null</td>
<td>AbstractMap</td>
<td>锁分段技术(JDK8:CAS)</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为null</td>
<td>允许为null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为null</td>
<td>允许为null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>允许为null</td>
<td>允许为null</td>
<td>HashMap</td>
<td>安全</td>
</tr>
</tbody></table>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>Hashtable 默认的初始化容量为 11，负载因子0.75，扩容是原来的2n+1</p>
<p>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个数组，粒度比较大，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p>
<h2 id="如果使用类作为HashMap的key，应该怎么办"><a href="#如果使用类作为HashMap的key，应该怎么办" class="headerlink" title="如果使用类作为HashMap的key，应该怎么办"></a>如果使用类作为HashMap的key，应该怎么办</h2><p>​    重写hashCode()，因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能导致更多的Hash碰撞</p>
<p>​    重写equals()，需要遵守自反性(x.equals(x)必须返回 true)，对称性( x.equals(y)返回true时，y.equals(x)也必须返回true)，传递性(xequals(y)和y.equals(z)都返回true时，x.equals(Z)也必须返回true)，一致性(当x和y引用的对象信息没有被修改时，多次调用x.equals (y)应该得到同样的返回值)以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</p>
<h2 id="HashMap为什么不直接使用hashCode-计算后的哈希值直接作为table的下标"><a href="#HashMap为什么不直接使用hashCode-计算后的哈希值直接作为table的下标" class="headerlink" title="HashMap为什么不直接使用hashCode()计算后的哈希值直接作为table的下标?"></a>HashMap为什么不直接使用hashCode()计算后的哈希值直接作为table的下标?</h2><p>​     hashCode()方法返回的是int整数类型，其范围为(2个31)<del>(2 ^ 31 - 1),约有40亿个映射空间,而HashMap的容量范围是在16(初始化默认值)</del>2^30;HashMap通常情况下是取不到最大值的,并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</li>
<li>TreeMap基于红黑树(Red-Black tree)实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator 进行排序，具体取决于使用的构造方法。</li>
<li>TreeMap 是线程非同步的。</li>
</ul>
<h2 id="comparable和comparator的区别"><a href="#comparable和comparator的区别" class="headerlink" title="comparable和comparator的区别?"></a>comparable和comparator的区别?</h2><ul>
<li>Comparable 接口实际上是出自java.lang包，它有一个CompareTo(Object obj)方法用来排序</li>
<li>Comparator 接口实际上是出自java.util 包, 它有一个Compare(Object obj1,Object obj2)方法用来排序</li>
<li>“一般我们需要对一个集合使用自定义排序时，我们就要重写CompareTo方法或Compare方法,当我们需要对某一个集合实现两种排序方式,比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写CompareTo方法和使用自制的Compara方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections,sort()。</li>
</ul>
<h2 id="Collection和Collections-有什么区别"><a href="#Collection和Collections-有什么区别" class="headerlink" title="Collection和Collections 有什么区别?"></a>Collection和Collections 有什么区别?</h2><ul>
<li>java.util.Collection 是一个集合接口(集合类的一个顶级接口) 。它提供了对集合对象进行基本操作的通用接口方法.    Collection接口在Java类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操<br>作方式，其直接继承接口有List与Set。</li>
<li>Collections 则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h2 id="TreeMap-和-TreeSet-在排序时如何比较元素"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素"></a>TreeMap 和 TreeSet 在排序时如何比较元素</h2><p>​       TreeMap和TreeSet 要求<strong>存放的对象所属的类必须实现Comparable接口或者利用构造器传入comparator接口</strong>，该接口提供了比较元素的comparTo()方法，当插入元素时会回调该方法比较元素的大小</p>
<h2 id="HashMap和ConcurrentHashMap的区别"><a href="#HashMap和ConcurrentHashMap的区别" class="headerlink" title="HashMap和ConcurrentHashMap的区别"></a>HashMap和ConcurrentHashMap的区别</h2><p>ConcurrentHashMap对每个桶都用CAS和synchronized 结合实现更加细粒度的锁，多线程操作只会锁住当前操作索引的结点。</p>
<p>HashMap的键值对允许有null。ConcurrentHashMap都不允许，因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。</p>
<h2 id="JDK1-8-中为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？"><a href="#JDK1-8-中为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？" class="headerlink" title="***JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？"></a>***JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？</h2><ul>
<li><p>在JDK1.6中，对synchronized锁的实现引入的大量的优化，并且synchronized有多中锁状态，会从无锁–&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁 一步步升级</p>
</li>
<li><p>减少内存开销，假设使用可重入锁来获取同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持，只有链表的头结点需要同步，这无疑就带来了巨大的内存浪费</p>
</li>
</ul>
<h2 id="ConcurrentHashMap的put方法"><a href="#ConcurrentHashMap的put方法" class="headerlink" title="ConcurrentHashMap的put方法"></a>ConcurrentHashMap的put方法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果有空值或者空键，直接抛异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//基于key计算hash值，并进行一定的扰动</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span>
    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果数组还未初始化，先对数组进行初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>
                         <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span>
            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//普通链表节点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            K ek<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                                          value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//树节点，将元素添加到红黑树中</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>
                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                                       value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//链表长度大于等于8，将链表转成红黑树</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>
                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//如果是重复键，直接将旧值返回</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span>
    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>总结：</p>
<ul>
<li><p>根据key计算出hash值；</p>
</li>
<li><p>判断是否需要进行初始化</p>
</li>
<li><p>定位到node，拿到首节点f，判断首节点f：</p>
<ul>
<li>如果为null，通过CAS的方式尝试添加</li>
<li>如果 (fh = f.hash) == MOVED 为true，说明其他线程在扩容，协助扩容</li>
<li>如果都不满足，synchronized锁住f节点，判断是链表还是红黑树，遍历插入</li>
</ul>
</li>
<li><p>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树</p>
</li>
</ul>
<h2 id="ConcurrentHashMap的get方法"><a href="#ConcurrentHashMap的get方法" class="headerlink" title="ConcurrentHashMap的get方法"></a>ConcurrentHashMap的get方法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> K ek<span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//计算哈希值</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//通过key定位到数组下标是否为空，判断数组是否为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//判断是否在桶上，如果在，直接返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//如果是红黑树，从红黑树里查询</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> null<span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//如果是链表结构，循环遍历判断</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li><p>根据 key 计算出 hash 值，判断数组是否为空；</p>
</li>
<li><p>如果是首节点，就直接返回；</p>
</li>
<li><p>如果是<a target="_blank" rel="noopener" href="https://blog.csdn.net/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>结构，就从<a target="_blank" rel="noopener" href="https://blog.csdn.net/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>里面查询；</p>
</li>
<li><p>如果是<a target="_blank" rel="noopener" href="https://blog.csdn.net/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>结构，循环遍历判断</p>
</li>
</ul>
<h2 id="ConcurrentHashMap-迭代器是强一致性还是弱一致性？"><a href="#ConcurrentHashMap-迭代器是强一致性还是弱一致性？" class="headerlink" title="ConcurrentHashMap 迭代器是强一致性还是弱一致性？"></a>ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h2><p>​    与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。</p>
<p>​    ConcurrentHashMap 的迭代器创建之后，就会按照hash表结构遍历每个元素，但在遍历过程中，内部元素可能发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</p>
<h2 id="使用Collections-synchronizedMap方法，对方法进行加同步锁。"><a href="#使用Collections-synchronizedMap方法，对方法进行加同步锁。" class="headerlink" title="使用Collections.synchronizedMap方法，对方法进行加同步锁。"></a>使用Collections.synchronizedMap方法，对方法进行加同步锁。</h2><p>​    如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p>
<h2 id="生产者—消费者问题"><a href="#生产者—消费者问题" class="headerlink" title="生产者—消费者问题"></a>生产者—消费者问题</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Condition<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">AirConditioner</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//1.判断</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//2.干活</span>
            number<span class="token operator">++</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//3.通知</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            number<span class="token operator">--</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadWaitNotifyDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        AirConditioner airConditioner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AirConditioner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//生产线程</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    airConditioner<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    airConditioner<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       
        <span class="token comment" spellcheck="true">//消费线程</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    airConditioner<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    airConditioner<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="线程安全单例模式"><a href="#线程安全单例模式" class="headerlink" title="线程安全单例模式"></a>线程安全单例模式</h2><p>方式一</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Inner<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>方式二</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Singleton singleton<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="java中wait和sleep的区别"><a href="#java中wait和sleep的区别" class="headerlink" title="java中wait和sleep的区别"></a>java中wait和sleep的区别</h2><p>​    sleep()方法(休眠)是线程类(Thread)的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会(CPU) 让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复就绪状态 。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁(线程暂停执行) ，进入对象的等待池(wait pool) ，只有调用对象的notify()方法(或notifyAlI()方法)时才能唤醒等待池中的线程进入等锁池(lock pool)， 如果线程重新获得对象的锁就可以进入就绪状态。</p>
<h2 id="Java-的sleep-方法和yield-方法有什么区别"><a href="#Java-的sleep-方法和yield-方法有什么区别" class="headerlink" title="***Java 的sleep()方法和yield()方法有什么区别?"></a>***Java 的sleep()方法和yield()方法有什么区别?</h2><p>​    sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会; yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</p>
<p>​    线程执行 sleep()方法后转入阻塞(blocked)状态，时间结束后才恢复就绪状态。而执行yield()方法后转入就绪(ready) 状态</p>
<p>​    sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常。</p>
<h2 id="怎么将byte转换为String"><a href="#怎么将byte转换为String" class="headerlink" title="怎么将byte转换为String?"></a>怎么将byte转换为String?</h2><p>使用String的构造器，不过使用时要显示的标明编码规则</p>
<h2 id="Java中-操作符是线程安全的吗"><a href="#Java中-操作符是线程安全的吗" class="headerlink" title="Java中++操作符是线程安全的吗?"></a>Java中++操作符是线程安全的吗?</h2><p>​    不是线程安全的操作，它涉及到多个指令，读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差</p>
<p>java中的 i++ 是否是原子操作？ 答案：不是</p>
<p>i = 0； 两个线程分别对i进行 ++100次，值是多少？   答案 ： 2 ~ 200 之间都有可能</p>
<table>
<thead>
<tr>
<th>a线程</th>
<th>b线程</th>
</tr>
</thead>
<tbody><tr>
<td>i = 0</td>
<td>i = 0</td>
</tr>
<tr>
<td>i++</td>
<td>被a打断</td>
</tr>
<tr>
<td>…  到 i=99</td>
<td>被a打断</td>
</tr>
<tr>
<td>被b打断</td>
<td>i++</td>
</tr>
<tr>
<td>被b打断</td>
<td>i = 1</td>
</tr>
<tr>
<td>i = 1</td>
<td>被a打断</td>
</tr>
<tr>
<td>被b打断</td>
<td>i ++</td>
</tr>
<tr>
<td>被b打断</td>
<td>直到   i = 100</td>
</tr>
<tr>
<td>i ++</td>
<td>b结束</td>
</tr>
<tr>
<td>i = 2</td>
<td>b结束</td>
</tr>
</tbody></table>
<h2 id="System-out-println-3-0-1-0-3"><a href="#System-out-println-3-0-1-0-3" class="headerlink" title="System.out.println(3 * 0.1 == 0.3);"></a>System.out.println(3 * 0.1 == 0.3);</h2><p>false，因为有些浮点数不能完全精确表示出来，在计算机中 3 * 0.1 = 0.30000000000000004</p>
<h2 id="64位JVM中，int的长度是多少"><a href="#64位JVM中，int的长度是多少" class="headerlink" title="64位JVM中，int的长度是多少"></a>64位JVM中，int的长度是多少</h2><p>​    Java中，int类型变量的长度是一个固定值，与平台无关，都是32位，意思就是说，在32位和64位的java虚拟机中，int类型的长度是相同的</p>
<h2 id="Java中WeakReference、SoftReference-和-StrongReference"><a href="#Java中WeakReference、SoftReference-和-StrongReference" class="headerlink" title="Java中WeakReference、SoftReference 和 StrongReference"></a>Java中WeakReference、SoftReference 和 StrongReference</h2><p>StrongReference：在实际开发中最为普遍的引用。申请一个内存空间的时候，就已经是强引用了。</p>
<p>SoftReference ：拥有强引用的属性，并且更加安全。如果有一个对象具有软引用，在内存空间足够的情况下，除非内存空间接近临界值，jvm即将抛出oom的时候，垃圾回收器才会将该引用对象进行回收，避免了系统内存溢出的情况</p>
<p>WeakReference：与软引用对比来说，弱引用的生命周期更短。当垃圾回收器扫描到只有弱引用的对象的时候，不管内存空间是否足够，都会直接被垃圾回收器回收。不过也不用特别担心，垃圾回收器是一个优先级比较低的现场，因此不一定很快可以发现弱引用的对象。</p>
<h2 id="编写多线程时候遵循哪些最佳实践"><a href="#编写多线程时候遵循哪些最佳实践" class="headerlink" title="***编写多线程时候遵循哪些最佳实践"></a>***编写多线程时候遵循哪些最佳实践</h2><ul>
<li><p>使用线程池</p>
</li>
<li><p>给线程命名，调试方便</p>
</li>
<li><p>最小化同步的范围，只对关键部分做同步</p>
</li>
<li><p>使用高层次的并发工具，比如CountDownLatch，Semeaphore等</p>
</li>
<li><p>优先使用并发集合，而不是对集合进行同步，并发集合提供更好的可扩展性</p>
</li>
</ul>
<h2 id="Sql优化有哪些方法"><a href="#Sql优化有哪些方法" class="headerlink" title="Sql优化有哪些方法"></a>Sql优化有哪些方法</h2><ul>
<li>表的设计要规范</li>
<li>适当建立索引，在频繁作为检索条件，更新较少的字段上建立索引，以提高查询速度</li>
<li>分表查询</li>
<li>读写分离</li>
<li>建立存储过程</li>
</ul>
<h2 id="一个文件中是否有多个类"><a href="#一个文件中是否有多个类" class="headerlink" title="一个文件中是否有多个类"></a>一个文件中是否有多个类</h2><p>可以，但是只能有一个类是public的，而且这个类的名字和文件名必须一致</p>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是一个或一组sql语句组成的一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<ul>
<li>原子性：事务中各个元素不可分割，全部执行成功或者撤销所有</li>
<li>一致性：事务执行前后数据的状态保持一致</li>
<li>持久性：事务完成后对系统的影响是永久的</li>
<li>隔离性：事务之间是隔离的，不能相互影响</li>
</ul>
<h2 id="Get和Post请求的区别"><a href="#Get和Post请求的区别" class="headerlink" title="Get和Post请求的区别"></a>Get和Post请求的区别</h2><ul>
<li>get发送的文本内容大小有限，而post请求没有限制</li>
<li>get请求的请求参数会出现在URL路径中，而发送post请求时，参数不会显示在url中，相对安全</li>
<li>get只能发送字符串，post请求可以提交二进制数据，post上传文件的时候。form表单的enctype为 Mulitipart/form-data</li>
</ul>
<h2 id="计算机网络有几层"><a href="#计算机网络有几层" class="headerlink" title="计算机网络有几层"></a>计算机网络有几层</h2><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<h2 id="Synchronized关键字的使用"><a href="#Synchronized关键字的使用" class="headerlink" title="Synchronized关键字的使用"></a>Synchronized关键字的使用</h2><p>对于普通同步方法，锁是当前对象<br>对于静态同步方法，锁是当前类的Class对象。<br>对于同步代码块，锁是Synchronized括号里配置的对象</p>
<p>Synchronized修饰的方法被继承的话，子类只是一个普通的类，并没有锁的功能了</p>
<p><strong>Synchronized修饰代码块的时候，锁尽量不要是String类的，因为字符串常量池具有缓存功能</strong></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>​    在一个，应用程序中初始化一个线程集合，然后在需要执行新的任务时重用线程池中的线程，而不是创建一个新的线程。”线程池中的每个线程都有被分配一个任务，一旦任务完成，线程就回到线程池中，等待下一次的任务分配。</p>
<p>优点：</p>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li>提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</li>
</ul>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><ul>
<li><p>执行Servlet构造器方法</p>
</li>
<li><p>指定init初始化方法</p>
</li>
</ul>
<ul>
<li><p>执行 service 方法</p>
</li>
<li><p>执行destroy销毁方法</p>
</li>
</ul>
<h2 id="Session与cookie的区别"><a href="#Session与cookie的区别" class="headerlink" title="Session与cookie的区别?"></a>Session与cookie的区别?</h2><p>Session保存在服务端，cookie保存在客户端</p>
<p>Session保存的是对象，cookie保存的是字符串</p>
<p>Session在服务器关闭后自动消失，cookie不会</p>
<h2 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h2><ul>
<li>存储过程的关键字是 procedure，函数的关键字是 function</li>
<li>函数必须有返回值，存储过程没有返回值，但是有传出参数</li>
<li>函数注重的结果，存储过程注重的是过程</li>
<li>函数是select调用，存储过程是 call 调用</li>
</ul>
<h2 id="jsp的作用域有哪些"><a href="#jsp的作用域有哪些" class="headerlink" title="jsp的作用域有哪些"></a>jsp的作用域有哪些</h2><p>PageContext：在当前页面有效</p>
<p>Request：在一次请求内有效</p>
<p>Session：在一次会话中有效</p>
<p>Application：在整个工程中有效</p>
<h2 id="重定向和请求转发的区别"><a href="#重定向和请求转发的区别" class="headerlink" title="重定向和请求转发的区别?"></a>重定向和请求转发的区别?</h2><p>​    请求转发只能将请求转发给同一个Web应用中的其他资源，而重定向不仅可以定向到当前应用程序中的其他资源，也可以重定向到其他站点上的资源。</p>
<p>​    重定向结束后，浏览器地址栏显示URL会发生改变,由初始的URL地址变成重定向的目标URL.而请求转发过程结束后,浏览器地址栏保持初始的URL地址不变。</p>
<p>​    转发是发生在服务端的，重定向是发生在客户端的</p>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="***多态性"></a>***多态性</h2><p>​    简单来说就是用同样的对象调用同样的方法但是做了不同的事情。多态性又分为编译时多态性和运行时多态性，方法重载就是编译时多态性，而方法重写就是运行时多态性，运行时多态性就是面向对象的核心，要求必须有方法重写和父类的引用指向子类的对象。</p>
<h2 id="包装类的缓存"><a href="#包装类的缓存" class="headerlink" title="包装类的缓存"></a>包装类的缓存</h2><p>​    如果整型字面量的值在-128到127之间,那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1f2的结果是true,而f3f4的结果是false。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Integer f1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>f2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>f3 <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">,</span>f4 <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f1 <span class="token operator">==</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f3 <span class="token operator">==</span> f4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<table>
<thead>
<tr>
<th>包装类型</th>
<th>基本数据类型</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td>Boole</td>
<td>boolean</td>
<td>true,false</td>
</tr>
<tr>
<td>Byte</td>
<td>byte</td>
<td>-128~127</td>
</tr>
<tr>
<td>Short</td>
<td>short</td>
<td>-128~127</td>
</tr>
<tr>
<td>Integer</td>
<td>int</td>
<td>-128~127</td>
</tr>
<tr>
<td>Long</td>
<td>long</td>
<td>-128~127</td>
</tr>
<tr>
<td>Character</td>
<td>char</td>
<td>0~127</td>
</tr>
<tr>
<td>Float</td>
<td>float</td>
<td>无</td>
</tr>
<tr>
<td>Double</td>
<td>double</td>
<td>无</td>
</tr>
</tbody></table>
<h2 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h2><p>基本数据类型转字符串：调用String类的ValueOf()方法返回相应的字符串或者用 加上一个空字符串</p>
<h2 id="怎样将GB2312编码的字符串转换为IS0-8859-1编码的字符"><a href="#怎样将GB2312编码的字符串转换为IS0-8859-1编码的字符" class="headerlink" title="***怎样将GB2312编码的字符串转换为IS0-8859-1编码的字符"></a>***怎样将GB2312编码的字符串转换为IS0-8859-1编码的字符</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    String s1 <span class="token operator">=</span> <span class="token string">"你好"</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"GB2312"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="try-里有一个return语句-那么紧跟在这个try后的finally-里的代码会不会被执行-什么时候被执行-在return前还是后"><a href="#try-里有一个return语句-那么紧跟在这个try后的finally-里的代码会不会被执行-什么时候被执行-在return前还是后" class="headerlink" title="try{}里有一个return语句,那么紧跟在这个try后的finally{}里的代码会不会被执行,什么时候被执行,在return前还是后?"></a>try{}里有一个return语句,那么紧跟在这个try后的finally{}里的代码会不会被执行,什么时候被执行,在return前还是后?</h2><p>​    会执行，在方法返回调用者之前执行。</p>
<p>​    在finally中改变返回值的做法不好，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值等待finally代码块执行完之后再向调用者返回其值，如果在finally中修改了返回值，就会返回修改后的值，显然，在finally中返回或者修改会对程序造成很大的困扰。</p>
<h2 id="什么是DAO模式"><a href="#什么是DAO模式" class="headerlink" title="什么是DAO模式"></a>什么是DAO模式</h2><p>​    DAO就是一个为持久化机制提供了接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种对数据的操作，在实际开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共的API中。DAO模式包含了两个模式，一个是Data Accessor(数据访问器)，Data Object(数据对象)，前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据</p>
<h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h2><p>这里只说明隔离性：并发执行的事务彼此无法看到对方的中间状态</p>
<p>【只有在并发数据访问时才需要事务】</p>
<p>并发下存在的问题，脏读，幻读，不可重复读，更新丢失(第一类、第二类)</p>
<p>解决这些问题直接用锁是很麻烦的，所以数据库为用户提供了事务隔离级别，使用指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁</p>
<h2 id="JDBC如何处理事务"><a href="#JDBC如何处理事务" class="headerlink" title="JDBC如何处理事务"></a>JDBC如何处理事务</h2><p>​    在Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务，当事务完成后用commit()显示提交事务，如果在事务处理过程中发生异常则通过rollback()进行事务回滚，还可以通过Savepoint来设置保存点，用于让事务回滚到指定的保存点</p>
<h2 id="正则表达式的用途"><a href="#正则表达式的用途" class="headerlink" title="正则表达式的用途"></a>正则表达式的用途</h2><p>​    正则表达式就是记录文本规则的代码。用来查找符合规则的字符串，string类提供了支持正则表达式的方法，例如 </p>
<ul>
<li>matches()</li>
<li>replaceAll()</li>
<li>replace()</li>
<li>split()</li>
</ul>
<h2 id="如何通过反射创建对象"><a href="#如何通过反射创建对象" class="headerlink" title="如何通过反射创建对象"></a>如何通过反射创建对象</h2><p>方法1：通过类对象调用  newInstance()方法</p>
<p>方法2：通过类对象的  getDeclaredConstructor() 获取构造器对象并调用  newInstance() 方法创建对象，例如</p>
<p>​            String.class.getDeclaredConstructor(String.class).newInstance(“hello”);</p>
<h2 id="如何通过反射获取和设置对象私有字段的值"><a href="#如何通过反射获取和设置对象私有字段的值" class="headerlink" title="如何通过反射获取和设置对象私有字段的值"></a>如何通过反射获取和设置对象私有字段的值</h2><p>通过类对象的 getDeclaredFiled() 方法返回Field对象，然后再通过字段对象的 setAccessible(true) 将其设置为可以访问，接下来就可以通过  get/set 方法来获取/设置字段的值了。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Field name <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    name<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    name<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span><span class="token string">"hhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><ul>
<li>以字节为单位输入输出数据，字节流按照8位传输，继承inputStream和OutputStream</li>
<li>以字符为单位输入输出数据，字符流按照16位传输，继承自Reader和Writer</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190418184716728.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODc1NTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="字节流和字符流哪个好？怎么选择？"><a href="#字节流和字符流哪个好？怎么选择？" class="headerlink" title="字节流和字符流哪个好？怎么选择？"></a>字节流和字符流哪个好？怎么选择？</h2><ol>
<li>大多数情况下使用字节流会更好，因为大多数时候 IO 操作都是直接操作磁盘文件，所以这些流在传输时都是以字节的方式进行的（图片等都是按字节存储的）</li>
<li>如果对于操作需要通过 IO 在内存中频繁处理字符串的情况使用字符流会好些，因为字符流具备缓存区，提高了性能</li>
</ol>
<p>字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件</p>
<h2 id="什么是缓存区？有什么作用？"><a href="#什么是缓存区？有什么作用？" class="headerlink" title="什么是缓存区？有什么作用？"></a>什么是缓存区？有什么作用？</h2><ol>
<li>缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性。</li>
<li>对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓存区刷新到文件则可以使用 flush() 方法操作。</li>
</ol>
<h2 id="InputStream里的read-返回的是什么-read-byte-data-是什么意思-返回的是什么值？"><a href="#InputStream里的read-返回的是什么-read-byte-data-是什么意思-返回的是什么值？" class="headerlink" title="***InputStream里的read()返回的是什么,read(byte[] data)是什么意思,返回的是什么值？"></a>***InputStream里的read()返回的是什么,read(byte[] data)是什么意思,返回的是什么值？</h2><ul>
<li>返回的是所读取的字节的int型（范围0-255），如果返回-1，则表明读取结束</li>
</ul>
<pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        FileReader fr <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//1.实例化File类的过程，指明要操作的文件</span>
            File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//相较于当前Module</span>
            <span class="token comment" spellcheck="true">//2. 提供具体的流</span>
            fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//3.数据的读入</span>
            <span class="token comment" spellcheck="true">//read():返回读入的一个字符。如果达到文件末尾，返回 -1</span>
            <span class="token keyword">int</span> data<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>data <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//4.流的关闭操作</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>fr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    fr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>read（byte [ ] data）将读取的字节储存在这个数组。返回的就是传入数组参数个数</li>
</ul>
<pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFileReader1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        FileReader fr <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//1.File类的实例化</span>
            File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//2.FileReader流的实例化</span>
            fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//3.读入的操作</span>
            <span class="token comment" spellcheck="true">//read(cahr[] cbuf):返回每次读入cbuf数组中的字符个数。如果达到文件末尾，返回-1</span>
            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cbuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> len<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//方式一：</span>
                <span class="token comment" spellcheck="true">//错误的写法</span>
<span class="token comment" spellcheck="true">//                for (int i = 0; i &lt;cbuf.length ; i++) &amp;#123;</span>
<span class="token comment" spellcheck="true">//                    System.out.println(cbuf[i]);</span>
<span class="token comment" spellcheck="true">//                &amp;#125;</span>

                <span class="token comment" spellcheck="true">//正确的</span>
<span class="token comment" spellcheck="true">//                for (int i = 0; i &lt;len; i++) &amp;#123;</span>
<span class="token comment" spellcheck="true">//                    System.out.print(cbuf[i]);</span>
<span class="token comment" spellcheck="true">//                &amp;#125;</span>

                <span class="token comment" spellcheck="true">//方式二：</span>
                <span class="token comment" spellcheck="true">//对应方式一的错误写法</span>
<span class="token comment" spellcheck="true">//                String str = new String(cbuf);</span>
<span class="token comment" spellcheck="true">//                System.out.println(str);</span>
                <span class="token comment" spellcheck="true">//正确的写法</span>
                String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//4.资源的关闭</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                fr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="OutputStream里面的write-是什么意思-write-byte-b-int-off-int-len-这个方法里面的三个参数分别是什么意思？"><a href="#OutputStream里面的write-是什么意思-write-byte-b-int-off-int-len-这个方法里面的三个参数分别是什么意思？" class="headerlink" title="OutputStream里面的write()是什么意思,write(byte b[], int off, int len)这个方法里面的三个参数分别是什么意思？"></a>OutputStream里面的write()是什么意思,write(byte b[], int off, int len)这个方法里面的三个参数分别是什么意思？</h2><ol>
<li>write将指定字节传入数据源</li>
<li>byte b[ ]是byte数组</li>
<li>off是传入的第一个字符、len-1是传入的最后的一个字符 、len是实际长度</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 从内存中写出数据到硬盘的文件里
 * 说明：
 * 1.输出操作，对应的File是可以不存在的,并不会报异常
 * 2.File对应硬盘中的文件
 * 如果不存在，在输出过程中，会自动创建此文件。
 * 如果存在，
 * 使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件覆盖
 * 使用的构造器是：FileWriter(file,true):不会对原有文件覆盖而是在原有文件基础上追加内容
 */</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFileWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    FileWriter fw <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//1.提供File类的对象，指明写出到的文件</span>
        File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"hello1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//2.提供FileWriter的对象，用于数据的写出</span>
        fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//3.写出的操作</span>
        fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"I have a dream！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"You need to have a dream!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//4.流资源的关闭</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fw <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                fw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用FileReader和FileWriter实现文本文件复制</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFileReaderFileWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    FileReader fr <span class="token operator">=</span> null<span class="token punctuation">;</span>
    FileWriter fw <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//1.创建File类的对象，指明读入和写出的文件</span>
        File srcFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        File destFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"hello2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//不能使用字符流来处理图片等字节数据</span>

        <span class="token comment" spellcheck="true">//2.创建输入流和输出流的对象</span>
        fr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span>destFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//3.数据的读入和写出操作</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cbuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录每次读入到cbuf数组中的字符的个数</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//每次写出len个字符</span>
            fw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//4.关闭流资源</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fw <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                fw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                fr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h2><p>​     Linux 是一套类似Unix的操作系统，一般的web项目和其他的一些项目所需要的东西都是部署在Linux上的，Linux是一个多用户，多线程和多CPU的操作系统。它继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h2 id="Windows-和-Linux-的区别"><a href="#Windows-和-Linux-的区别" class="headerlink" title="Windows 和 Linux 的区别"></a>Windows 和 Linux 的区别</h2><ul>
<li>Windows 适合于普通用户使用，Linux 适合软件开发部署</li>
<li>Linux 可以针对机器的配置有针对性的优化</li>
<li>Linux 是免费的，Windows 是收费的</li>
</ul>
<h2 id="Unix-和-Linux-有什么区别"><a href="#Unix-和-Linux-有什么区别" class="headerlink" title="Unix 和 Linux 有什么区别"></a>Unix 和 Linux 有什么区别</h2><p>​    开源性：Linux是一款开源操作系统，不需要付费，即可使用; Unix是一款对源码实行知识产权保护的传统商业软件,使用需要付费授权使用。</p>
<p>​    跨平台性：Linux 操作系统具有良好的跨平台性，而Unix操作系统的跨平台性能较弱</p>
<p>​    可视化界面：Linux 有，Unix没有</p>
<p>​    硬件环境：Linux 对硬件要求较低，Unix较高</p>
<p>​    </p>
<h2 id="什么是Linux内核"><a href="#什么是Linux内核" class="headerlink" title="什么是Linux内核"></a>什么是Linux内核</h2><p>​    linux系统的核心是内核，内核控制着计算机系统上的所有硬件和软件，在必要的时候分配硬件，还可以根据需要执行软件</p>
<h2 id="什么是root账户"><a href="#什么是root账户" class="headerlink" title="什么是root账户"></a>什么是root账户</h2><p>​    root帐户就像是个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。</p>
<h2 id="什么是硬链接-和-软链接"><a href="#什么是硬链接-和-软链接" class="headerlink" title="什么是硬链接 和 软链接"></a>什么是硬链接 和 软链接</h2><p>​    硬链接可以认为是一个指向文件索引节点的指针。</p>
<p>​    软链接也叫符号链接，类似于windows 里的快捷方式，主要存放了链接其他文件的路径，当原文件移动到其他目录中，在访问链接文件系统就找不到了，实际场景下使用软连接比较多</p>
<p>​     软连接示例：在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录   ln  -s  /root  LinkToRoot</p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>一个Shell脚本就是一个文件，包含一个或多个命令，将这些命令在配合一定的逻辑来完成一些日常的工作</p>
<h2 id="Linux运行级别"><a href="#Linux运行级别" class="headerlink" title="Linux运行级别"></a>Linux运行级别</h2><p>0 ：关机<br>1 ：单用户【可以找回丢失的密码】<br>2：多用户状态没有网络服务<br>3：多用户状态有网络服务<br>4：保留<br>5：图形界面<br>6：系统重启</p>
<h2 id="Tomcat的8005、8009、8080三个端口的含义"><a href="#Tomcat的8005、8009、8080三个端口的含义" class="headerlink" title="Tomcat的8005、8009、8080三个端口的含义"></a>Tomcat的8005、8009、8080三个端口的含义</h2><p>8005：关闭时使用</p>
<p>8009：容器使用</p>
<p>8080：一般应用使用</p>
<h2 id="网站的灰度发布"><a href="#网站的灰度发布" class="headerlink" title="网站的灰度发布"></a>网站的灰度发布</h2><p>​    灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式，ABtest就是一种灰度发布方式，让一部分用户继续使用A，一部分用户开始使用B，如果用户对B没有什么反对意见，就逐步扩大范围，把所有的用户都迁移到B上面来。</p>
<p>​    灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现，调整问题，以保证其影响度</p>
<h2 id="Linux有几种状态"><a href="#Linux有几种状态" class="headerlink" title="Linux有几种状态"></a>Linux有几种状态</h2><ul>
<li>不可中断状态：进程处于睡眠状态，此刻的进程不响应异步信号  D</li>
<li>暂停状态/跟踪状态：向进程发送一个SIGSTOP信号，他就会因响应信号而进入TASK_STOPPED状态；当前进程正在被跟踪时，它处于TASK_TRACED状态。【正被跟踪：指的是进程暂停下来，等待跟踪它的进程对它进行操作】 T</li>
<li>就绪状态：在run_queue队列里的状态   </li>
<li>运行状态   R </li>
<li>可中断睡眠状态：处于这个状态的进程因为等待某个事件的发生而被挂起。  S</li>
<li>僵尸状态：进程运行结束，父进程尚未使用wait来收尸，也就是在等待父进程销毁它   Z</li>
<li>退出状态 </li>
</ul>
<h2 id="查看后台任务的命令"><a href="#查看后台任务的命令" class="headerlink" title="查看后台任务的命令"></a>查看后台任务的命令</h2><p>jobs  -l</p>
<h2 id="把后台任务调到前台-把停下的后台任务在后台执行起来"><a href="#把后台任务调到前台-把停下的后台任务在后台执行起来" class="headerlink" title="把后台任务调到前台;把停下的后台任务在后台执行起来"></a>把后台任务调到前台;把停下的后台任务在后台执行起来</h2><p>​    把后台任务调到前台  fg , 如果后台中有多个命令，可以用fg %jobnumber（是命令编号，不是进程号）将选中的命令调出</p>
<p>​    把停下的后台任务在后台执行起来  bg，将一个在后台暂停的命令，变成在<strong>后台</strong>继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出</p>
<h2 id="查看系统支持的所有信号"><a href="#查看系统支持的所有信号" class="headerlink" title="查看系统支持的所有信号"></a>查看系统支持的所有信号</h2><p>kill  -l</p>
<h2 id="查看磁盘使用空间和空闲空间"><a href="#查看磁盘使用空间和空闲空间" class="headerlink" title="查看磁盘使用空间和空闲空间"></a>查看磁盘使用空间和空闲空间</h2><p>df -hl</p>
<h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><p>env :查看所有</p>
<p>查看home环境变量：env $HOME</p>
<h2 id="查看整个文件，显示行号，有文本的显示行号"><a href="#查看整个文件，显示行号，有文本的显示行号" class="headerlink" title="查看整个文件，显示行号，有文本的显示行号"></a>查看整个文件，显示行号，有文本的显示行号</h2><p>cat -n a.txt</p>
<p>cat -b a.txt</p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210903214035.png"></p>
<h2 id="进程放到后台运行"><a href="#进程放到后台运行" class="headerlink" title="进程放到后台运行"></a>进程放到后台运行</h2><p>./aa.sh &amp;</p>
<p>把 aa.sh 放到后台运行</p>
<h2 id="验证网络可连接命令以及原理"><a href="#验证网络可连接命令以及原理" class="headerlink" title="验证网络可连接命令以及原理"></a>验证网络可连接命令以及原理</h2><p>​    使用ping命令。这个ping命令发送一个特殊的网络数据包到一台指定的主机。大多数接收这个包的网络设备将会恢复它来允许网络连接验证，一旦启动，会持续在特定时间发送数据包</p>
<h2 id="查看端口是否被占用"><a href="#查看端口是否被占用" class="headerlink" title="查看端口是否被占用"></a>查看端口是否被占用</h2><p>netstat -ntulp | grep  端口号</p>
<p>n：拒绝显示别名，能显示数字的都转换为数字</p>
<p>t: 仅显示tcp相关选项</p>
<p>u:仅显示udp相关选项</p>
<p>l : 仅列出在 Listen的服务状态</p>
<p>p : 显示建立相关连接的程序名</p>
<h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><ul>
<li><p>mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去加载驱动，创建连接、创建statement等过程</p>
</li>
<li><p>mybatis可以使用 xml或注解来配置和映射原生信息，将pojo映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</p>
</li>
<li><p>通过xml文件和注解的方式将要执行的各种statement配置起来，并通过java对象和参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回</p>
</li>
</ul>
<h2 id="MyBatis的优点"><a href="#MyBatis的优点" class="headerlink" title="MyBatis的优点"></a>MyBatis的优点</h2><p>​    MyBatis不会对应用程序或者数据库现有的设计造成任何影响，SQL写在xml里，解除sql与程序代码的耦合，便于统一管理；还支持编写动态SQL语句</p>
<p>​    与JDBC相比，消除了JDBC大量冗余的代码</p>
<p>​    提供映射标签，支持对象与数据库的ORM字段关系映射</p>
<h2 id="MyBatis框架的缺点有什么"><a href="#MyBatis框架的缺点有什么" class="headerlink" title="MyBatis框架的缺点有什么"></a>MyBatis框架的缺点有什么</h2><p>SQL语句的编写工作量较大</p>
<p>SQL语句依赖于数据库，导致数据库一致性差，不能随意更换数据库</p>
<h2 id="MyBatis是如何分页的、分页插件原理是什么"><a href="#MyBatis是如何分页的、分页插件原理是什么" class="headerlink" title="MyBatis是如何分页的、分页插件原理是什么"></a>MyBatis是如何分页的、分页插件原理是什么</h2><p>​    MyBatis自带的分页查询是内存分页。</p>
<p>​    物理分页可以在SQL内直接书写分页的参数来完成分页功能，或者使用分页插件来实现</p>
<p>​    分页插件的原理：使用MyBatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截等待执行的sql，然后重写sql，添加对应的物理分页语句和物理分页参数实现分页</p>
<h2 id="MyBatis如何封装结果并返回的"><a href="#MyBatis如何封装结果并返回的" class="headerlink" title="MyBatis如何封装结果并返回的"></a>MyBatis如何封装结果并返回的</h2><ul>
<li>使用resultmap标签，逐一定义数据库列名和对象属性名之间的映射关系</li>
<li>使用别名</li>
<li>使用resultype属性，值为要封装的类名</li>
</ul>
<h2 id="MyBatis编程步骤"><a href="#MyBatis编程步骤" class="headerlink" title="MyBatis编程步骤"></a>MyBatis编程步骤</h2><p>​    创建 SqlSessionFactory 对象 ，通过 SqlSessionFactory 得到 SqlSession 对象，通过 SqlSession 获取接口的代理对象mapper，代理对象执行接口中的方法，提交增删改(默认是不提交的)，最后关闭会话</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   
   <span class="token comment" spellcheck="true">//1.根据全局配置文件得到SqlSessionFactory对象</span>
   String resource <span class="token operator">=</span> <span class="token string">"mybatis-config.xml"</span><span class="token punctuation">;</span>
   InputStream inputStream <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
   SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token comment" spellcheck="true">//2.获取sqlSession对象，可以指定参数，默认为false，意为不自动提交，可以改为true</span>
   SqlSession sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//3.获取接口实现类的对象</span>
      <span class="token comment" spellcheck="true">//会为接口自动创建一个代理对象，代理对象去执行增删改查方法</span>
      EmployeeMapper mapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>EmployeeMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      Employee empployee <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getEmpById</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//class com.sun.proxy.$Proxy4</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token comment" spellcheck="true">//sqlSession.commit();</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//4.关闭sqlSession</span>
      sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="JDBC-和-MyBatis-相比有哪些不足之处，MyBatis-是怎么解决的"><a href="#JDBC-和-MyBatis-相比有哪些不足之处，MyBatis-是怎么解决的" class="headerlink" title="JDBC 和 MyBatis 相比有哪些不足之处，MyBatis 是怎么解决的"></a>JDBC 和 MyBatis 相比有哪些不足之处，MyBatis 是怎么解决的</h2><ul>
<li>SQL语句写在代码中，维护代价高，MyBatis 写在配置文件中，实现了代码和sql语句的分离，提高了代码的维护性</li>
<li>jdbc在组合SQL语句的时候需要拼接，MyBatis 有动态sql，更加方便和灵活</li>
<li>jdbc对结果集的封装麻烦，MyBatis 自动将SQL执行结果集映射到java对象中</li>
</ul>
<h2 id="使用MyBatis-的mapper接口调用时候有哪些要求"><a href="#使用MyBatis-的mapper接口调用时候有哪些要求" class="headerlink" title="使用MyBatis 的mapper接口调用时候有哪些要求"></a>使用MyBatis 的mapper接口调用时候有哪些要求</h2><ul>
<li><p>mapper.xml的namespace就是接口的全类名</p>
</li>
<li><p>mapper 接口方法名和 mapper.xml中定义的每个SQL的id相同</p>
</li>
<li><p>如果接口中方法的参数有多个的话，需要@Param注解来标明这个map参数集合的key是什么，因为MyBatis 底层会把参数都封装成map集合</p>
</li>
</ul>
<h2 id="MyBatis-配置文件中有哪些标签"><a href="#MyBatis-配置文件中有哪些标签" class="headerlink" title="MyBatis 配置文件中有哪些标签"></a>MyBatis 配置文件中有哪些标签</h2><p>properties、setting、typeAliases、plugins、environments、transactionManager、dataSource、mappers等</p>
<h2 id="MyBatis-缓存机制"><a href="#MyBatis-缓存机制" class="headerlink" title="MyBatis 缓存机制"></a>MyBatis 缓存机制</h2><p>使用的是PerpetualCache（永久缓存）类，存储原理就是==<strong>map集合</strong>==</p>
<h3 id="一级缓存（本地缓存）"><a href="#一级缓存（本地缓存）" class="headerlink" title="一级缓存（本地缓存）"></a>一级缓存（本地缓存）</h3><ul>
<li>sqlSession级别的缓存，<strong>一级缓存是一直开启的</strong>，查出的数据都会放在map中<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要获取获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li>
<li>一级缓存失效的情况 (没有使用到当前一级缓存的情况下，就还需要在向数据库发出查询)<ul>
<li>sqlSession不相同</li>
<li>sqlSession相同，查询条件不同</li>
<li>SQLSession相同，两次查询之间执行了增删改(这次增删改可能对当前数据有影响)</li>
<li>SQLSession相同，手动清除了一级缓存（缓存清空）   <strong>sqlSession1.clearCache();</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​      </p>
<h3 id="二级缓存（全局缓存）"><a href="#二级缓存（全局缓存）" class="headerlink" title="二级缓存（全局缓存）"></a>二级缓存（全局缓存）</h3><ul>
<li><p>基于namespace级别的缓存；一个namespace对应一个二级缓存</p>
</li>
<li><p>工作机制：</p>
<ul>
<li>一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中</li>
<li>查出的数据会默认放在一级缓存中</li>
<li>如果关闭会话，一级缓存的数据会被保存到二级缓存中。新的会话查询信息，就可以参照二级缓存中的数据</li>
<li>如果会话没关闭，其他会话查询相同数据时还是会再次发sql语句</li>
<li>同一个会话查出的不同namespace中的数据会放在自己对应的二级缓存中</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>在全局配置文件中 开启二级缓存配置：&lt;setting name=”cacheEnabled” value=”true”/&gt;</p>
</li>
<li><p>mapper.xml中配置使用二级缓存：</p>
<ul>
<li><p>&lt;cache&gt;&lt;/cache&gt;</p>
</li>
<li><pre><code>cache的一些属性介绍：

   eviction:缓存的回收策略：
      • LRU  – 最近最少使用的：移除最长时间不被使用的对象。
      • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
      • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
      • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
      • 默认的是 LRU。
   flushInterval：缓存刷新间隔
      缓存多长时间清空一次，默认不清空，设置一个毫秒值

   readOnly:是否只读：
      true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。
            mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快
      false：非只读：mybatis觉得获取的数据可能会被修改。
            mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢

   size：缓存存放多少元素；

   type=&quot;&quot;：指定自定义缓存的全类名；实现Cache接口即可；
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>POJO需要实现序列化接口</strong></p>
<ul>
<li>序列化：把一个Java对象写入到硬盘或者传输到网路上面的其它计算机，需要把相应的对象写成转换成字节流。</li>
</ul>
</li>
</ul>
<h3 id="和缓存有关的设置-属性"><a href="#和缓存有关的设置-属性" class="headerlink" title="和缓存有关的设置/属性"></a>和缓存有关的设置/属性</h3><ul>
<li><p>全局配置文件中的 &lt;setting&gt; 标签中cacheEnabled属性，为true一级、二级都可用；为false二级关闭，一级一直可用</p>
</li>
<li><p>每个select标签都有useCache=”true”的属性：一级、二级都可用</p>
<pre><code>   false：一级缓存依然使用，二级缓存不使用
</code></pre>
</li>
<li><p>每个增删改标签的：flushCache=”true”属性：增删改执行完成后就会清除缓存（一级二级都会清除）</p>
</li>
</ul>
<p>​        每个查询标签也有：flushCache=”false”属性</p>
<ul>
<li>sqlSession.clearCache();只是清除当前session的一级缓存；</li>
<li>&lt;setting&gt;标签中有localCacheScope本地缓存作用域：<pre><code>SESSION ；当前会话的所有数据保存在会话缓存中；
STATEMENT：可以禁用一级缓存；
</code></pre>
</li>
</ul>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210729104529.png"></p>
<h2 id="Mybatis的映射文件"><a href="#Mybatis的映射文件" class="headerlink" title="Mybatis的映射文件"></a>Mybatis的映射文件</h2><p>Mybatis的映射文件是mybatis 的核心之一，里面包含了cache、resultMap、insert、update、delete、select等</p>
<h2 id="MyBatis的动态SQL"><a href="#MyBatis的动态SQL" class="headerlink" title="MyBatis的动态SQL"></a>MyBatis的动态SQL</h2><ul>
<li>if：简单的条件判断</li>
<li>Choose(when/otherwies)，相当于switch</li>
<li>Trim：对包含的内容加上prefix，或者suffix</li>
<li>where：条件判断，可以去掉多余的一个and/or</li>
<li>Set：更新的时候使用</li>
<li>Foreach：查询的时候特别有用</li>
</ul>
<p>原理：使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能</p>
<h2 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{} 和  ${} 的区别是什么"></a>#{} 和  ${} 的区别是什么</h2><p>​    #{}是预编译处理，${}是字符串替换</p>
<p>#{}在处理时会将sql中的#{}替换为 ? ，调用preparedstatement的set方法来赋值</p>
<p>预编译指的就是数据库驱动在发送SQL语句和参数给DBMS之前对SQL语句进行编译，相当于一个模板，往进传参数就行了</p>
<p>${}在处理时将变量替换为参数</p>
<h2 id="如何获取自动生成主键值"><a href="#如何获取自动生成主键值" class="headerlink" title="如何获取自动生成主键值"></a>如何获取自动生成主键值</h2><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 获取自增主键的值
   mybatis支持获取自增主键，通过statement.getGenreatedKeys()
   useGeneratedKeys="true":使用自增主键获取主键值策略
   keyProperty:指定对应的主键属性，mybatis获取主键值后将这个值封装给JavaBean的这个属性
--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addEmp<span class="token punctuation">"</span></span> <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    insert  into tbl_employee(last_name, email, gender)
    values (#<span class="token entity" title="&#123;">&amp;#123;</span>lastName<span class="token entity" title="&#125;">&amp;#125;</span>, #<span class="token entity" title="&#123;">&amp;#123;</span>email<span class="token entity" title="&#125;">&amp;#125;</span>, #<span class="token entity" title="&#123;">&amp;#123;</span>gender<span class="token entity" title="&#125;">&amp;#125;</span>)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="MyBatis中不同的xml映射文件，id是否可以重复"><a href="#MyBatis中不同的xml映射文件，id是否可以重复" class="headerlink" title="MyBatis中不同的xml映射文件，id是否可以重复"></a>MyBatis中不同的xml映射文件，id是否可以重复</h2><p>不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置，则不能重复</p>
<p>​    原因就是namespace + id 是作为map&lt;String,MapperStatement&gt;的key使用的，如果没有namespace，就剩下id，id重复就会导致数据互相覆盖，有了namespace，id就可以重复了，namespace不同，namespace + id自然也就不同</p>
<p>【Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt; 标签，都会被解析为一个MapperStatement对象。】</p>
<h2 id="一对一，一对多的关联查询"><a href="#一对一，一对多的关联查询" class="headerlink" title="一对一，一对多的关联查询"></a>一对一，一对多的关联查询</h2><p>一对一，一对多的关联查询都有两种方法：联合查询和嵌套查询</p>
<p>在 &lt;resultMap&gt;标签中，使用&lt;association&gt;实现一对一关联查询，使用&lt;collection&gt;实现一对多关联查询</p>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--自定义某个javaBean的封装规则
    type：自定义规则的java类型
    id：唯一id方便引用
--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyEmp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token comment" spellcheck="true">&lt;!--指定主键的封装规则
     id定义主键底层有优化
     column：指定哪一列
     property:指定对应的JavaBean属性
   --></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token comment" spellcheck="true">&lt;!--定义普通列封装规则--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>last_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token comment" spellcheck="true">&lt;!--其他不指定的列会自动封装，但是只要写resultMap最好把全部的映射规则都写上--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!--resultMap:自定义结果集映射规则--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmpById<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyEmp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   select * from  tbl_employee where id= #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>


<span class="token comment" spellcheck="true">&lt;!-- 
   场景一：查询Employee的同时查询员工对应的部门 Employee===Department 一个员工有与之对应的部门信息； id last_name gender d_id did dept_name (private Department dept;) 
--></span>
<span class="token comment" spellcheck="true">&lt;!-- 方式一：联合查询，级联属性封装结果集 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDifEmp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>last_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

   <span class="token comment" spellcheck="true">&lt;!--需要Employee类的dept属性的get方法--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept.id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept.departmentName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!--方式二：使用association定义关联的单个对象的封装规则：--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDifEmp2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Employee<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>last_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

   <span class="token comment" spellcheck="true">&lt;!--
     association可以指定联合的javaBean对象
     property="dept";指定哪个属性是联合的对象
     javaType:指定这个属性对象的类型[不能省略]
    --></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>departmentName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmpAndDept<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDifEmp2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id, d.id did,d.dept_name dept_name
   FROM tbl_employee e, tbl_dept d
   WHERE e.d_id = d.id AND e.id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>


<span class="token comment" spellcheck="true">&lt;!-- 使用association进行分步查询：
     1、先按照员工id查询员工信息
     2、根据查询员工信息中的d_id值去部门表查出部门信息
     3、部门设置到员工中；
 --></span>
<span class="token comment" spellcheck="true">&lt;!--  id  last_name  email   gender    d_id   --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyEmpByStep<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>last_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token comment" spellcheck="true">&lt;!-- association定义关联对象的封装规则
            select:表明当前属性是调用select指定的方法查出的结果
            column:指定将哪一列的值传给这个方法

            流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性
         --></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept<span class="token punctuation">"</span></span>
                <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.dao.DepartmentMapper.getDeptById<span class="token punctuation">"</span></span>
                <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>d_id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>
<span class="token comment" spellcheck="true">&lt;!--  public Employee getEmpByIdStep(Integer id);--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getEmpByIdStep<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyEmpByStep<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   select * from tbl_employee where id=#<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!--可以使用延迟查询(按需加载|懒加载)
    Employee ==> Dept
       每次查询Employee对象的是时候，都得一起查询出来
       部门信息在使用的时候再去查询
       分段查询的基础上加两个配置

    全局配置
    懒加载必须搭配aggressiveLazyLoading使用，光开启懒加载没用
    &lt;setting name="lazyLoadingEnabled" value="true"/>
    &lt;setting name="aggressiveLazyLoading" value="false"/>
--></span>


<span class="token comment" spellcheck="true">&lt;!--
场景二：
   查询部门的时候将部门对应的所有员工信息也查询出来
   嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则
--></span>
<span class="token comment" spellcheck="true">&lt;!--
   private Integer id;
   private String departmentName;
   private List&lt;Employee> emps;
--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDept<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>did<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>departmentName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token comment" spellcheck="true">&lt;!--
            collection定义关联集合类型的属性的封装规则
            ofType:指定集合里面元素的类型
        --></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token comment" spellcheck="true">&lt;!--定义这个集合元素的封装规则--></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>last_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getDeptByIdPlus<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDept<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   SELECT d.id did, d.dept_name dept_name ,
   e.id eid, e.last_name last_name, e.email email, e.gender gender
   FROM tbl_dept d
   LEFT JOIN tbl_employee e
   ON d.id = e.d_id
   WHERE d.id  = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 分步查询 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDeptStep<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.bean.Department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dept_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>departmentName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span>
               <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.mybatis.dao.EmployeeMapperPlus.getEmpsByDeptId<span class="token punctuation">"</span></span>
               <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">fetchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token comment" spellcheck="true">&lt;!--或者 column="&amp;#123;deptId = id&amp;#125;"--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getDeptByIdStep<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyDeptStep<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>
   select id, dept_name departmentName  from tbl_dept where d_id=#<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="mybatis的延迟加载"><a href="#mybatis的延迟加载" class="headerlink" title="mybatis的延迟加载"></a>mybatis的延迟加载</h2><pre class=" language-xml"><code class="language-xml">懒加载必须搭配aggressiveLazyLoading使用，光开启懒加载没用
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aggressiveLazyLoading<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
【补充：mapUnderscoreToCamelCase 驼峰命名法】
</code></pre>
<p>​    原理：使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器invoke()方法发现 a.getB()是null值，那么就会单独发送实现保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是对象a的b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<h2 id="mybatis-的接口绑定"><a href="#mybatis-的接口绑定" class="headerlink" title="mybatis 的接口绑定"></a>mybatis 的接口绑定</h2><p>接口绑定，就是在Mybatis中任意定义接口，再把接口里面的方法和SQL语句绑定，直接调用接口方法就可以了</p>
<p>一种是通过注解绑定，就是在接口的方法上面加上@select、@update等注解，里面包含sql语句来绑定，</p>
<p>一种是通过xml文件来写sql。</p>
<p>当sql语句比较简单就可以用注解绑定，sql语句比较复杂的时候用xml绑定，一般用xml绑定的比较多</p>
<h2 id="Mybatis是如何进行分页，以及插件原理"><a href="#Mybatis是如何进行分页，以及插件原理" class="headerlink" title="Mybatis是如何进行分页，以及插件原理"></a>Mybatis是如何进行分页，以及插件原理</h2><p>使用RowBounds对象进行分页，或者直接编写sql，或者使用mybatis的分页插件</p>
<p>插件原理：</p>
<ol>
<li>mybatis仅可以编写ParameterHandler、ResultSetHandler、StatementHandler、Executor这4个接口的插件，mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4个接口对象的方法时，就会进入拦截方法，具体的逻辑就是在invocationHandler的invoke()方法。</li>
<li>实现mybatis的interceptor接口并复写 intercept()方法，然后再给插件编写注解，指定要拦截哪个接口的方法即可</li>
<li>在配置文件中配置插件</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 完成插件签名：
 *        告诉MyBatis当前插件用来拦截哪个对象的哪个方法
 */</span>
<span class="token annotation punctuation">@Intercepts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token annotation punctuation">@Signature</span><span class="token punctuation">(</span>type<span class="token operator">=</span>StatementHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>method<span class="token operator">=</span><span class="token string">"parameterize"</span><span class="token punctuation">,</span>args<span class="token operator">=</span>java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>Statement<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstPlugin</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * intercept：拦截：
     *         拦截目标对象的目标方法的执行；
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyFirstPlugin...intercept:"</span><span class="token operator">+</span>invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询3号员工</span>
        Object target <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前拦截到的对象："</span><span class="token operator">+</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//拿到：StatementHandler==>ParameterHandler===>parameterObject</span>
        <span class="token comment" spellcheck="true">//拿到target的元数据</span>
        MetaObject metaObject <span class="token operator">=</span> SystemMetaObject<span class="token punctuation">.</span><span class="token function">forObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object value <span class="token operator">=</span> metaObject<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">"parameterHandler.parameterObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sql语句用的参数是："</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//修改完sql语句要用的参数</span>
        metaObject<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"parameterHandler.parameterObject"</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//执行目标方法</span>
        Object proceed <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//返回执行后的返回值</span>
        <span class="token keyword">return</span> proceed<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * plugin：
     *         包装目标对象的：包装：为目标对象创建一个代理对象
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Object <span class="token function">plugin</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//我们可以借助Plugin的wrap方法来使用当前Interceptor包装我们目标对象</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyFirstPlugin...plugin:mybatis将要包装的对象"</span><span class="token operator">+</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object wrap <span class="token operator">=</span> Plugin<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//返回为当前target创建的动态代理</span>
        <span class="token keyword">return</span> wrap<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * setProperties：
     *         将插件注册时的property属性设置进来
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProperties</span><span class="token punctuation">(</span>Properties properties<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"插件配置的信息："</span><span class="token operator">+</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//当有多个插件时，是按照插件配置的顺序一层一层的代理代理对象，执行目标的方法之后，按照逆向顺序执行</span>
</code></pre>
<h2 id="Mybatis和xml映射文件和内部数据结构之间的映射关系"><a href="#Mybatis和xml映射文件和内部数据结构之间的映射关系" class="headerlink" title="Mybatis和xml映射文件和内部数据结构之间的映射关系"></a>Mybatis和xml映射文件和内部数据结构之间的映射关系</h2><p>​    MyBatis将所有的全局配置信息都封装到Configuration内部。在Xml映射文件中，标签会被解析为ParamaterMap对象，其每个子元素会解析为ParamaterMapping对象。标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象，每一个增删改查标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h2 id="通常一个xml映射文件对应一个dao接口与之对应，其内部的方法可以重载吗"><a href="#通常一个xml映射文件对应一个dao接口与之对应，其内部的方法可以重载吗" class="headerlink" title="通常一个xml映射文件对应一个dao接口与之对应，其内部的方法可以重载吗"></a>通常一个xml映射文件对应一个dao接口与之对应，其内部的方法可以重载吗</h2><p>不能重载，因为通过Dao寻找xml对应的方法的时候全类名+方法名的方式寻找，如果方法名一样的话会有冲突。</p>
<h2 id="Mybatis映射文件，如果A标签通过include引用了B标签内容。A、B标签有顺序要求吗"><a href="#Mybatis映射文件，如果A标签通过include引用了B标签内容。A、B标签有顺序要求吗" class="headerlink" title="Mybatis映射文件，如果A标签通过include引用了B标签内容。A、B标签有顺序要求吗"></a>Mybatis映射文件，如果A标签通过include引用了B标签内容。A、B标签有顺序要求吗</h2><p>​    虽然Mybatis解析xml映射文件是按照顺序解析的。但是被引用B标签依然可以定义在任何地方，都可以被正确识别的，Mybatis解析A标签，发现A标签用了B标签，但是B标签尚未被解析到，此时Mybatis会将A标签标记为未解析状态，然后继续解析剩余的标签，待所有标签解析完成后，MyBatis会重新解析那些被标记为未解析的标签，此时在解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<h2 id="Mybatis的几个Executor执行器以及区别"><a href="#Mybatis的几个Executor执行器以及区别" class="headerlink" title="Mybatis的几个Executor执行器以及区别"></a>Mybatis的几个Executor执行器以及区别</h2><p>共有三个执行器 </p>
<ul>
<li>SimpleExecutor：每一次执行update或select，就开启一个statement对象，<strong>用完立刻关闭</strong></li>
<li>RruseExecutor：定义了一个Map&lt;String, Statement&gt;，将执行的sql作为key，将执行的Statement作为value保存，执行相同的sql时就可以使用已经存在的Statement，就不需要新创建，并且<strong>用完之后不关闭</strong>，如果不存在，放置于map内，供下次使用</li>
<li>BatchExecutor：批处理</li>
</ul>
<p>可以通过DefaultSqlSessionFactory创建SqlSession的方法传递ExecutorType类型参数</p>
<h2 id="Mybatis原理"><a href="#Mybatis原理" class="headerlink" title="Mybatis原理"></a>Mybatis原理</h2><p>1、获取sqlSessionFactory对象:<br>      解析文件的每一个信息保存在Configuration中，返回包含Configuration的DefaultSqlSession；<br>      注意：【MappedStatement】：代表一个增删改查的详细信息</p>
<p>2、获取sqlSession对象<br>      返回一个DefaultSqlSession对象，包含Executor和Configuration;<br>      这一步会创建Executor对象；用于增删改查的执行</p>
<p>3、获取接口的代理对象（MapperProxy），一个接口就对应这一个MapperProxyFactory<br>      getMapper，使用MapperProxyFactory创建一个MapperProxy的代理对象<br>      代理对象里面包含了，DefaultSqlSession（Executor）</p>
<p>4、执行增删改查方法</p>
<p>总结：<br>   1、根据配置文件（全局，sql映射）初始化出Configuration对象<br>   2、创建一个DefaultSqlSession对象，<br>      他里面包含Configuration以及Executor（根据全局配置文件中的defaultExecutorType创建出对应的Executor）<br> 3、DefaultSqlSession.getMapper（）：拿到Mapper接口对应的MapperProxy；<br> 4、MapperProxy里面有（DefaultSqlSession）；<br> 5、执行增删改查方法：<br>      1）调用DefaultSqlSession的增删改查（Executor）；<br>      2）会创建一个StatementHandler对象。<br>         （同时也会创建出ParameterHandler和ResultSetHandler）<br>      3）调用StatementHandler预编译参数以及设置参数值;<br>         使用ParameterHandler来给sql设置参数<br>      4）调用StatementHandler的增删改查方法；<br>      5）ResultSetHandler封装结果<br> 注意：<br>   四大对象每个创建的时候都有一个interceptorChain.pluginAll(parameterHandler);</p>
<h2 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h2><p>Nginx是高性能的HTTP和反向代理的服务器，处理并发能力十分强悍，可以实现</p>
<ul>
<li><p>反向代理：</p>
<ul>
<li>只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，接着返回给客户端，此时反向代理服务器和目标对外就是一个服务，暴露的是代理服务器地址隐藏了真实的服务器地址</li>
<li>优点：反向代理服务器可以隐藏服务器的存在和特征，它充当服务器之间的中间层，这对于安全来说是很好的</li>
</ul>
</li>
<li><p>负载均衡</p>
<ul>
<li>将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器</li>
</ul>
</li>
<li><p>动静分离</p>
<ul>
<li>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</li>
</ul>
</li>
</ul>
<h2 id="Nignx如何处理HTTP请求"><a href="#Nignx如何处理HTTP请求" class="headerlink" title="***Nignx如何处理HTTP请求"></a>***Nignx如何处理HTTP请求</h2><ol>
<li>Nginx在启动时，会解析配置文件，得到需要监听的端口和ip地址，然后在Nginx的master进程里面先初始化好监控的sokcet</li>
<li>然后再fork(一个现有进程可以调用fork函数创建一个新进程)出多个子进程</li>
<li>此时，客户端就可以向nginx发起连接了，当客户端与nginx进行三次握手，与nginx建立好一个连接后，子进程竞争accept新的连接，某一个进程会accept成功，得到这个建立好的连接socker，然后创建nginx对连接的封装。ngx_connection_t</li>
<li>接着设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换</li>
</ol>
<h2 id="在Nignx中，如何使用未定义的服务器名称来阻止处理请求"><a href="#在Nignx中，如何使用未定义的服务器名称来阻止处理请求" class="headerlink" title="在Nignx中，如何使用未定义的服务器名称来阻止处理请求"></a>在Nignx中，如何使用未定义的服务器名称来阻止处理请求</h2><p>只需要将请求删除的服务器定义为：</p>
<pre class=" language-pr"><code class="language-pr">Server&#123;
    listen 80;
    server_name " ";
    return 444;
&#125;
</code></pre>
<p>服务器名被保留位一个空字符串，它将没有主机头字段的情况下匹配请求，而一个特殊的Nignx的非标准代码返回，从而终止连接。</p>
<h2 id="Nignx的Master-和-Worker进程"><a href="#Nignx的Master-和-Worker进程" class="headerlink" title="Nignx的Master 和 Worker进程"></a>Nignx的Master 和 Worker进程</h2><p>Master 进程：master进程负责管理worker进程，并负责读取配置文件和判断文件语法的工作，且只有一个。</p>
<p>Worker进程：用于处理请求，有多个</p>
<h2 id="Nignx是如何实现高并发"><a href="#Nignx是如何实现高并发" class="headerlink" title="Nignx是如何实现高并发"></a>Nignx是如何实现高并发</h2><p>​    一个主进程，多个工作进程，每个工作进程可以处理多个请求，每进来一个request，会有一个worker进程去处理，但不是全程的处理，处理到可能发生阻塞的地方，比如后端服务器转发request，并等待请求返回，那么，这个处理的worker继续处理其他请求，而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走，由于web服务器的工作性质决定了每个request的大部分生命都是在网络传输中，实际上花费在server机器上的时间片并不多，这就是几个进程就可以解决高并发的秘密所在。</p>
<h2 id="Nignx为什么不使用多线程"><a href="#Nignx为什么不使用多线程" class="headerlink" title="Nignx为什么不使用多线程"></a>Nignx为什么不使用多线程</h2><p>​    nginx使用单线程来处理异步非阻塞请求，不会为每个请求配置cpu和内存，节省了大量资源，同时也减少了大量的cpu上下文切换。</p>
<h2 id="为什么要做动静分离"><a href="#为什么要做动静分离" class="headerlink" title="为什么要做动静分离"></a>为什么要做动静分离</h2><p>​    在软件开发中，有些请求是需要后台处理的(如: .jsp等) ，有些请求是不需要经过后台处理的(如:cSS、html、jpg、 js 等等)，这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件，但是如果直接忽略静态文件的话，后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，应该使用这种动静分离的策略去解决动、静分<br>离将网站静态资源(HTML, JavaScript;CSS等)与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。这里将静态资源放到nginx中，动态资源转发到tomcat服务器中，毕竟Tomcat的优势是处理动态请求。</p>
<h2 id="fastcgi和cgi的区别"><a href="#fastcgi和cgi的区别" class="headerlink" title="fastcgi和cgi的区别"></a>fastcgi和cgi的区别</h2><ul>
<li>cgi<ul>
<li>web服务器会根据请求的内容，然后会fork一个新进程来运行外部c程序，这个进程会把处理完的数据返回给web服务器，最后web服务器把内容发送给用户，刚才fork的进程也随之退出</li>
<li>如果下次还请求，那么web服务器又再一次fork一个新进程，周而复始</li>
</ul>
</li>
<li>fastcgi<ul>
<li>web服务器收到一个请求时，不会重新fork一个进程，因为进程在web服务器启动时就开启了，而且不会退出，web服务器直接把内容传递给这个进程(tcp通信)，这个进程收到请求后进行处理，把结果返回给web服务器，最后自己接着等待下一个请求的到来，而不是退出</li>
</ul>
</li>
</ul>
<h2 id="nginx有哪些有优点"><a href="#nginx有哪些有优点" class="headerlink" title="nginx有哪些有优点"></a>nginx有哪些有优点</h2><ul>
<li>跨平台</li>
<li>非阻塞，高并发连接</li>
<li>可处理 2 - 3 万并发连接数</li>
<li>内存消耗小</li>
<li>成本低且开源</li>
<li>稳定性高，宕机的概率小</li>
</ul>
<h2 id="Nignx负载均衡的策略"><a href="#Nignx负载均衡的策略" class="headerlink" title="Nignx负载均衡的策略"></a>Nignx负载均衡的策略</h2><p>负载均衡就是代理服务器将接收到的请求均衡的分发到各服务器中</p>
<p>nginx默认提供了3种</p>
<ul>
<li>轮询(默认)<ul>
<li>每个请求按照时间顺序逐一分配到不同的后端服务器，如果服务端down掉，能自动剔除。</li>
</ul>
</li>
<li>ip哈希<ul>
<li>每个请求访问ip的hash结果分配，这样每个访客固定一个后端服务器，可以解决session共享问题</li>
</ul>
</li>
<li>权重<ul>
<li>权重值越大分配到了概率越高，主要用于后端每台服务器性能不均衡的情况下，其次是为在主从的情况下设置不同的权值，达到合理有效的利用主机资源</li>
</ul>
</li>
</ul>
<h2 id="location的作用是什么"><a href="#location的作用是什么" class="headerlink" title="location的作用是什么"></a>location的作用是什么</h2><p>根据不同用户请求的URL来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关操作</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>= 开头表示精确匹配</td>
</tr>
<tr>
<td>^~</td>
<td>^<del>开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^</del> /static/ /aa匹配到（注意是空格）</td>
</tr>
<tr>
<td>~</td>
<td>~ 开头表示区分大小写的正则匹配</td>
</tr>
<tr>
<td>~*</td>
<td>~* 开头表示不区分大小写的正则匹配</td>
</tr>
<tr>
<td>!~和!~*</td>
<td>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配的正则</td>
</tr>
<tr>
<td>/</td>
<td>用户所使用的代理（一般为浏览器</td>
</tr>
</tbody></table>
<pre><code>  location = / &#123;
      #规则A
  &#125;
  location = /login &#123;
      #规则B
  &#125;
  location ^~ /static/ &#123;
      #规则C
  &#125;
  location ~ \.(gif|jpg|png|js|css)$ &#123;
      #规则D
  &#125;
  location ~* \.png$ &#123;
      #规则E
  &#125;
  location !~ \.xhtml$ &#123;
      #规则F
  &#125;
  location !~* \.xhtml$ &#123;
      #规则G
  &#125;
  location / &#123;
      #规则H
  &#125;
</code></pre>
<h2 id="nginx如何限流"><a href="#nginx如何限流" class="headerlink" title="nginx如何限流"></a>nginx如何限流</h2><p>Nginx限流就是限制用户请求速度，防止服务器受不了</p>
<ul>
<li>正常限制访问频率</li>
<li>突发限制访问频率</li>
<li>限制并发连接数</li>
</ul>
<p>限流都是基于漏桶流算法：</p>
<p>​    突发流量会进入到一个漏桶，漏桶会按照定义的速率一次处理请求，如果突发流量过大就会直接溢出，则多余的请求会被拒绝，所以漏桶算法能够控制数据</p>
<p>【令牌桶算法：存在一个固定大小的令牌桶，会以恒定的速率远远不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直到装满整个令牌桶】</p>
<h2 id="nginx配置高可用"><a href="#nginx配置高可用" class="headerlink" title="nginx配置高可用"></a>nginx配置高可用</h2><p>使用 keepalived </p>
<p>在  /etc/keepalived/keepalived.conf 配置文件中进行配置</p>
<pre><code>global_defs &#123;
   notification_email &#123;
      acassen@firewall.loc
         failover@firewall.loc
         sysadmin@firewall.loc
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
      smtp_server 192.168.130.172
      smtp_connect_timeout 30
      router_id LVS_DEVEL
&#125;
vrrp_script chk_http_port &#123;
   script &quot;/usr/local/src/nginx_check.sh&quot;
      interval 2 #（检测脚本执行的间隔）
      weight 2
&#125;
vrrp_instance VI_1 &#123;
   state BACKUP # 备份服务器上将 MASTER 改为 BACKUP 
      interface ens33 //网卡
      virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同
      priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小
      advert_int 1
      authentication &#123;
      auth_type PASS
         auth_pass 1111
   &#125;
   virtual_ipaddress &#123;
      192.168.17.50 // VRRP H 虚拟地址
   &#125;
&#125;
</code></pre>
<pre class=" language-shell"><code class="language-shell">#!/bin/bash
A=`ps -C nginx –no-header |wc -l`
if [ $A -eq 0 ];then
    /usr/local/nginx/sbin/nginx
    sleep 2
    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then
    killall keepalived
    fi
fi
</code></pre>
<h2 id="Nginx怎么判断IP不可访问"><a href="#Nginx怎么判断IP不可访问" class="headerlink" title="Nginx怎么判断IP不可访问"></a>Nginx怎么判断IP不可访问</h2><pre class=" language-java"><code class="language-java">#如果访问ip地址为 <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">130.172</span><span class="token punctuation">,</span>则返回<span class="token number">403</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>$remote_addr <span class="token operator">=</span> <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">130.172</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">403</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="Rewirte全局变量是什么"><a href="#Rewirte全局变量是什么" class="headerlink" title="Rewirte全局变量是什么"></a>Rewirte全局变量是什么</h2><pre><code>$args    这个变量等于请求行中的参数，同$query_string
$content length    请求头中的Content-length字段。
$content_type    请求头中的Content-Type字段。
$document_root    当前请求在root指令中指定的值。
$host    请求主机头字段，否则为服务器名称。
$http_user_agent    客户端agent信息
$http_cookie    客户端cookie信息
$limit_rate    这个变量可以限制连接速率。
$request_method    客户端请求的动作，通常为GET或POST。
$remote_addr    客户端的IP地址。
$remote_port    客户端的端口。
$remote_user    已经经过Auth Basic Module验证的用户名。
$request_filename    当前请求的文件路径，由root或alias指令与URI请求生成。
$scheme    HTTP方法（如http，https）。
$server_protocol    请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
$server_addr    服务器地址，在完成一次系统调用后可以确定这个值。
$server_name    服务器名称。
$server_port    请求到达服务器的端口号。
$request_uri    包含请求参数的原始URI，不包含主机名，如”/foo/bar.php?arg=baz”。
$uri    不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。
$document_uri    与$uri相同。
</code></pre>
<h2 id="什么是Redis及优缺点"><a href="#什么是Redis及优缺点" class="headerlink" title="什么是Redis及优缺点"></a>什么是Redis及优缺点</h2><p>Redis：Remote Dictionary Server</p>
<p>​    Redis本质上是一个Key-Value类型的内存数据库，整个数据库统统加载到内存中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p>
<p>​    Redis性能是非常出色的，不过最大的魅力是在于Redis支持多种数据结构，比如list就可以作为轻量级的消息队列服务，此外单个value的最大限制是1GB。而且Redis 速度快，还支持事务。</p>
<p>​    Redis的主要缺点是数据库容量受到物理内存的限制，不能用做海量数据的高性能读写。</p>
<p>​    【补充：redis的key名要区分大小写】</p>
<h2 id="Redis-和-Memcached-相比有哪些优势"><a href="#Redis-和-Memcached-相比有哪些优势" class="headerlink" title="Redis 和 Memcached 相比有哪些优势"></a>Redis 和 Memcached 相比有哪些优势</h2><p>Memcached  所有的值均是简单的字符串，Redis 支持更丰富的数据类型</p>
<p>Redis 的速度比 memcache快很多</p>
<p>Redis 可以持久化数据</p>
<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>String、List、Set、ZSet、hashes</p>
<h2 id="Redis-数据淘汰策略"><a href="#Redis-数据淘汰策略" class="headerlink" title="Redis 数据淘汰策略"></a>Redis 数据淘汰策略</h2><p>根据淘汰策略可以实现Redis 中的数据都是热点数据</p>
<ul>
<li><p>no-eviction(默认) ： 对于写请求不再提供服务，直接返回错误，DEL请求和部分特殊请求除外</p>
</li>
<li><p>allkeys-lru：从所有key中使用LRU(最近最少使用)算法进行淘汰</p>
</li>
<li><p>volatile-lru：从设置了过期时间的key中使用LRU算法淘汰</p>
</li>
<li><p>allkeys-random：从所有key中随机淘汰</p>
</li>
<li><p>volatile-random：从设置了过期时间的key中随机淘汰</p>
</li>
<li><p>volatile-ttl：在设置了过期时间的key中，根据key 的过期时间进行淘汰，越快过期的越优先淘汰</p>
</li>
<li><p>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。</p>
</li>
<li><p>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。</p>
</li>
</ul>
<h2 id="为什么Redis-需要把所有数据放到内存中"><a href="#为什么Redis-需要把所有数据放到内存中" class="headerlink" title="为什么Redis 需要把所有数据放到内存中"></a>为什么Redis 需要把所有数据放到内存中</h2><p>Redis 为了达到最快的读写速度，所有将数据都读到内存中，并通过异步的方式将数据写入磁盘</p>
<p>如果不将数据放在内存中，磁盘  I/O  速度会严重影响Redis 的性能</p>
<p>【补充：<strong>Redis存储极限是系统中的可用内存值</strong>】</p>
<h2 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h2><p>​    首先计算出20w数据所需的内存空间，设置最大内存，然后选择合适的内存淘汰策略。比如说使用 xxx-lru 策略</p>
<h2 id="Redis-什么情况下会导致整个集群不可用"><a href="#Redis-什么情况下会导致整个集群不可用" class="headerlink" title="Redis 什么情况下会导致整个集群不可用"></a>Redis 什么情况下会导致整个集群不可用</h2><p>​    有 A  B  C 三个节点的集群，在没有复制模型的情况下，如果节点B失败了，那么整个集群就会以为缺少对应范围的卡槽而不可用</p>
<h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><p>是最常用的一种Redis 情景，用Redis 缓存会比其他存储的优势在于 Redis 提供持久化</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>Redis 在内存存储引擎领域 的一大优点是提供list和set操作，这使得Redis 能作为一个很好的消息队列平台来使用</p>
<h3 id="排行榜-计数器"><a href="#排行榜-计数器" class="headerlink" title="排行榜/计数器"></a>排行榜/计数器</h3><p>Redis 在内存中有对数字进行递增或递减的操作实现，还有集合和有序集合也使这些操作更加简单</p>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>Redis发布订阅（pub/sub）是一种消息通信模式：发送者（publish）发送消息，订阅者（subscribe）接收消息。</p>
<p>一个/多个客户端执行 subscribe  channel1 命令，就表示它订阅了 channel1</p>
<p>发布者执行  publish channel1  hello  ，客户端就可以收到增加的消息</p>
<h2 id="Redis-哈希槽"><a href="#Redis-哈希槽" class="headerlink" title="Redis 哈希槽"></a>Redis 哈希槽</h2><p>​    Redis 集群有16384个哈希槽，每个key通过CRC16校验后对 16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。所以集群最多可以有 16384个节点</p>
<h2 id="Redis-集群的主从复制模型是怎样的"><a href="#Redis-集群的主从复制模型是怎样的" class="headerlink" title="Redis 集群的主从复制模型是怎样的"></a>Redis 集群的主从复制模型是怎样的</h2><p>​    为了当部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</p>
<p>主从复制增加高可用性，但是只有Master 能进行写操作</p>
<p>集群增加扩展性</p>
<h2 id="Redis-集群的写丢失"><a href="#Redis-集群的写丢失" class="headerlink" title="Redis 集群的写丢失"></a>Redis 集群的写丢失</h2><ul>
<li><p>过期 key 被清理</p>
</li>
<li><p>最大内存不足，导致 Redis 自动清理部分 key 以节省空间</p>
</li>
<li><p>网络不稳定触发哨兵的自动切换主从节点，切换期间会有数据丢失</p>
</li>
</ul>
<h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>​    事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p>
<p>相关命令</p>
<p>MULTI(开始)  EXEC(结束)  DISCARD(放弃)  WATCH(监视key在添加进队里里面后是否有改变)</p>
<h2 id="Redis-key的过期时间和永久有效分别怎么设置"><a href="#Redis-key的过期时间和永久有效分别怎么设置" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置"></a>Redis key的过期时间和永久有效分别怎么设置</h2><p>EXPIRE和Persist命令</p>
<h2 id="Redis如何做内存优化"><a href="#Redis如何做内存优化" class="headerlink" title="Redis如何做内存优化"></a>Redis如何做内存优化</h2><p>​    尽可能使用散列表，散列表使用的内存很小，应该尽可能把数据模型抽象到一个散列表里面，比如有一个用户对象，不要为这个对象的名称、性别、年龄等单独设置key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h2 id="Redis回收线程如何工作的"><a href="#Redis回收线程如何工作的" class="headerlink" title="Redis回收线程如何工作的"></a>Redis回收线程如何工作的</h2><p>一个客户端运行了新的命令，添加了新的数据</p>
<p>Redis检查内存使用情况，如果大于 maxmemory的限制，则根据设定好的策略进行回收</p>
<h2 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决"></a>Redis的并发竞争问题如何解决</h2><ul>
<li>使用分布式锁<ul>
<li>传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。可以用zookeeper、redis</li>
</ul>
</li>
<li>使用消息队列：<ul>
<li>在并发量过大的情况下，可以通过消息中间件进行处理，把并行读写进行串行化。</li>
</ul>
</li>
</ul>
<p>使用redis实现分布式锁：</p>
<ul>
<li><p>使用 setnx 上锁，通过  del 释放锁</p>
</li>
<li><p>如果锁一直没有释放，设置key过期时间，自动释放</p>
</li>
<li><p>如果上锁之后突然出现异常，无法设置过期时间了，只需在上锁的同时设置过期时间就可以</p>
<ul>
<li>set  &lt;key&gt;  &lt;value&gt;  nx   ex   时长</li>
</ul>
</li>
</ul>
<h2 id="Redis-持久化的几种方式"><a href="#Redis-持久化的几种方式" class="headerlink" title="Redis 持久化的几种方式"></a>Redis 持久化的几种方式</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>​    Redis会单独创建( fork)一个子进程来进行持久化，<strong>会先将数据写入到一个临时文件中</strong>，待持久化过程都结束了，再用这个<strong>临时文件替换上次持久化好的文件</strong>（也称作写时复制）。整个过程中，主进程是不进行任何IO操作的,这就确保了极高的性能，</p>
<p>优点：</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>恢复速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
<li>如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>​    以日志的形式来记录每个写操作(增量保存)，将Redis执行过的**所有写指令记录下来(读操作不记录)**，只许追加文件但不可以改写文件,，redis启动之初会根据日志文件的内容将写指令从前到后执行一次，以完成数据的恢复工作。默认是不开启的，配置文件中把 appendonly  no    改为 appendonly  yes 就开启了</p>
<p>优点：</p>
<ul>
<li>备份机制追加文件，丢失数据概率更低</li>
</ul>
<p>缺点：</p>
<ul>
<li>比起RDB占用更多的磁盘空间</li>
<li>恢复备份速度要慢</li>
<li>每次读写都同步的话，有一定的性能压力</li>
</ul>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>​    Redis事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请所打断。</p>
<h2 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>Redis全量复制一般发生在Slave初始化截断，这时Slave需要将Master上的所有数据都复制一份，步骤如下：</p>
<ul>
<li>从服务器连接主服务器，发送SYNC命令</li>
<li>主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后所有的写命令</li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
<li>此后从服务器就可以接收来自用户的读请求。</li>
</ul>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>   Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<p>​    如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<p>​    如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p>
<p>​    </p>
<h2 id="假如Redis里面有1亿个key-其中有10w个key是以某个-固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如Redis里面有1亿个key-其中有10w个key是以某个-固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如Redis里面有1亿个key,其中有10w个key是以某个 固定的已知的前缀开头的，如果将它们全部找出来"></a>假如Redis里面有1亿个key,其中有10w个key是以某个 固定的已知的前缀开头的，如果将它们全部找出来</h2><p>​    使用keys指令可以扫出指定模式的key列表，比如 keys k*，就可以找出所有以k开头的key</p>
<p>​    特点： 1、在选定的库中，一次性全部返回符合条件的key，如果数据量很大将会等待很久， 因此，只适合用在可控的量小的键查询，比如几百，几千。 2、返回的键精确，不会重复，可放心使用。</p>
<p><strong>追问：</strong>如果这个Redis正在给线上的业务提供服务,那使用keys指令会有什么问题?</p>
<p>​    因为Redis 的单线程的。keys 指令会导致线程阻塞一段时间， 线上服务会停顿，直到指令执行完毕，服务才能恢复。这个<br>时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，需要在客户端做一次去重，但是整体所花费的时间会比直接用keys指令长。</p>
<p>例如：scan 0 match k*   可以找出所有以k开头的key</p>
<p>​    SCAN 命令是一个基于游标的迭代器，每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</p>
<p>SCAN 返回一个包含两个元素的数组， 第一个元素是用于进行下一次迭代的新游标， 而第二个元素则是一个数组， 这个数组中包含了所有被迭代的元素。如果新游标返回 0 表示迭代已结束。</p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210915115806.png"></p>
<h2 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案"></a>Redis常见性能问题和解决方案</h2><ul>
<li><p>Master 最好不要做任何持久化工作</p>
</li>
<li><p>如果数据比较重要，让某个Slave开启AOF备份数据</p>
</li>
<li><p>为了主从复制的稳定性，Master和Slave最好在同一个局域网内</p>
</li>
<li><p>主从复制不要用图状结构，用单向链表结构更为稳定，比如 master -&gt; slave1 -&gt; slave2….. ，如果Master挂了，可以立刻启用 Slave1做Master，其它不变。</p>
</li>
</ul>
<h2 id="Redis过期键的删除策略"><a href="#Redis过期键的删除策略" class="headerlink" title="Redis过期键的删除策略"></a>Redis过期键的删除策略</h2><ul>
<li><p>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p>
</li>
<li><p>惰性删除：放任键过期不管，但每次从键空间获取键是，都检查取得的键是否过期，如果过期的话就删除，没有过期就返回该键</p>
</li>
<li><p>定期删除：每隔一段时间就对数据库进行一次检查，删除里面的过期键</p>
</li>
</ul>
<p>三者的对比</p>
<table>
<thead>
<tr>
<th>删除策略</th>
<th>内存占用</th>
<th>CPU资源</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存</td>
<td>不分时段占用CPU</td>
<td>时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延迟执行，CPU利用率高</td>
<td>空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的CPU资源维护内存</td>
<td>随机抽查</td>
</tr>
</tbody></table>
<h2 id="Redis的Pipeline"><a href="#Redis的Pipeline" class="headerlink" title="Redis的Pipeline"></a>Redis的Pipeline</h2><p>​    Redis客户端执行一条命令分4个过程：  发送命令－〉命令排队－〉命令执行－〉返回结果。这个过程成为RTT(往返时间)，mget、mset有效的节约了RTT，但大部分操作还是不支持批量操作的，这个时候就需要Pipeline了，Pipeline是非原子性的，并且不建议一次性添加多个命令，会造成阻塞</p>
<ul>
<li>未使用pipeline执行N条命令</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181122105251930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxbGd5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>使用了pipeline执行N条命令</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181122105343203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxbGd5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Redis支持哪些-Java-客户端"><a href="#Redis支持哪些-Java-客户端" class="headerlink" title="Redis支持哪些 Java 客户端"></a>Redis支持哪些 Java 客户端</h2><p>Redisson、Jedis，推荐使用Redisson</p>
<p>他两的区别就是：</p>
<p>​    Jedis的API提供了对Redis比较全面的命令支持，而Redisson是实现了分布式和可扩展的 Java 数据结构，和jedis相比功能简单，不支持字符串操作，不支持排序、事务、管道、等Redis特性</p>
<h2 id="处理过大量的key同一时间过期吗？需要注意什么？"><a href="#处理过大量的key同一时间过期吗？需要注意什么？" class="headerlink" title="处理过大量的key同一时间过期吗？需要注意什么？"></a>处理过大量的key同一时间过期吗？需要注意什么？</h2><p>​    大量的 key 集中在某个时间点过期，Redis 可能会出现短暂的卡顿现象。如果访问量大的情况下，还可能出现缓存雪崩</p>
<p>处理办法：可以在时间上加一个随机值，分散过期时间点</p>
<h2 id="Redis做异步队列"><a href="#Redis做异步队列" class="headerlink" title="Redis做异步队列"></a>Redis做异步队列</h2><p>​    一般使用list结构作为队列，rpush生成消息，lpop消费消息，当lpop没有消息的时候，使用blpop阻塞直到消息的到来，可以用pub/sub主题订阅模式实现 1：N的消息队列</p>
<p>如何实现延迟队列</p>
<p>​    使用 sortedSet，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用 zrangebyscore指令获取N秒前的数据进行处理就行了</p>
<h2 id="Redis官方为什么不提供Windows版本"><a href="#Redis官方为什么不提供Windows版本" class="headerlink" title="Redis官方为什么不提供Windows版本"></a>Redis官方为什么不提供Windows版本</h2><p>​    因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h2 id="为什么要做Redis分区"><a href="#为什么要做Redis分区" class="headerlink" title="为什么要做Redis分区"></a>为什么要做Redis分区</h2><p>​    分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。Redis集群的时候就用到了哈希分区。</p>
<h2 id="查看redis使用情况以及状态信息用什么命令"><a href="#查看redis使用情况以及状态信息用什么命令" class="headerlink" title="查看redis使用情况以及状态信息用什么命令"></a>查看redis使用情况以及状态信息用什么命令</h2><p>info xxx</p>
<p>xxx可以是 CPU、Cluster等</p>
<h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><ul>
<li>完全基于内存</li>
<li>数据结构简单，对数据的操作也简单</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU。</li>
<li>不用考虑锁的问题，不存在因为死锁而导致的性能消耗</li>
</ul>
<h2 id="Redis是单线程-多路IO复用的理解"><a href="#Redis是单线程-多路IO复用的理解" class="headerlink" title="Redis是单线程+多路IO复用的理解"></a>Redis是单线程+多路IO复用的理解</h2><p>​     客户端与服务端建立连接交由socket，可以同时建立多个连接，redis会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（注意：不是探测哪个连接建立好了，而是探测哪个接收完了请求数据），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。这应该就是所谓的redis单线程</p>
<p>IO多路复用（IO Multiplexing）：异步阻塞IO<br>    多路IO复用有select，poll，epoll这些模式。select监测数量能力有限。poll监测数量没有限制，但是需要一个一个核查。配epoll监测数量没有限制，也不需要一个一个核查，直接看是否有一个正确的标识。起到一个监视的效果，就绪后，Redis直接执行，不需要等待，没有就绪时线程做其他事情</p>
<h2 id="Redis常用命令管理"><a href="#Redis常用命令管理" class="headerlink" title="Redis常用命令管理"></a>Redis常用命令管理</h2><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210915193657.png"></p>
<h2 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h2><p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断的发起请求。</p>
<p>解决：</p>
<ul>
<li>对空值进行缓存</li>
<li>设置可访问的名单：<ul>
<li>   使用bitmaps类型定义一个可以访问的名单 ，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截,不允许访问。</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h2><p>​    缓存击穿是指一条数据缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p>解决：</p>
<ul>
<li>预先设置热门数据</li>
<li>实时调整：现场监控哪些数据热门，实时调整key的过期时长</li>
<li>布隆过滤器<ul>
<li>算法：<ol>
<li>首先需要k个hash函数，每个函数可以把key散列成为1个整数</li>
<li>初始化时，需要一个长度为n比特的数组，每个比特位初始化为0</li>
<li>某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1</li>
<li> 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h2><p>​    缓存击穿是指一条数据缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p>解决：</p>
<ul>
<li>构建多级缓存架构：Nginx缓存 +  redis 缓存  +  其他缓存（ehcache）</li>
<li>将缓存失效时间分散开<pre><code>比如我们可以在原有的失效时间基础上增加一个随机值,比如1-5 分钟的随机值，这样每-一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
</code></pre>
</li>
</ul>
<h2 id="Redis实现附近的人"><a href="#Redis实现附近的人" class="headerlink" title="Redis实现附近的人"></a>Redis实现附近的人</h2><p>​    将给定的位置对象(纬度、经度、名字)添加到指定的key。其中，key为集合名称。</p>
<p>geoadd &lt;key&gt; &lt;longitude&gt;  &lt;latitude&gt;  &lt;member&gt;</p>
<ul>
<li>添加地理位置（经度，纬度，名称），可以添加多个</li>
</ul>
<h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>​    Spring 是一个轻量级的开源应用框架，旨在降低应用程序开发的复杂度，由于Spring的分层框架，用户可以自由选择自己需要的组件。</p>
<p>Spring 特点 </p>
<ul>
<li>方便解耦，简化开发 </li>
<li>Aop 编程支持 </li>
<li>方便程序测试 </li>
<li>方便和其他框架进行整合 </li>
<li>方便进行事务操作 </li>
<li>降低 API 开发难度</li>
</ul>
<h2 id="IOC-和-DI"><a href="#IOC-和-DI" class="headerlink" title="IOC 和 DI"></a>IOC 和 DI</h2><p>IOC 是控制反转(原理是工厂模式 + 反射机制)，DI是依赖注入，是IOC 的一方面</p>
<p>控制反转就是把对象的调用权交给容器，通过容器来创建对象并管理对象之间的依赖关系。</p>
<p>依赖注入就是把配置对象的工作交由容器负责。</p>
<p>依赖注入<strong>通过setter方法或者构造器来注入</strong>，setter注入前提是需要类用无参构造器创建对象</p>
<h2 id="Spring自动装配的方式"><a href="#Spring自动装配的方式" class="headerlink" title="Spring自动装配的方式"></a>Spring自动装配的方式</h2><p>Spring装配：就是bean在Spring容器中组合在一起时，就被称为装配，前提是容器需要知道bean的依赖关系</p>
<p>什么是bean的自动装配：容器能自动处理bean之间的协作</p>
<p>byName：根据bean的名字进行自动装配</p>
<p>byType：根据bean的类型进行自动装配</p>
<p>constructor：用构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。</p>
<p>自动装配的局限性：有覆盖的可能性、基本数据类型不能自动装配</p>
<h2 id="Spring中的IOC容器"><a href="#Spring中的IOC容器" class="headerlink" title="Spring中的IOC容器"></a>Spring中的IOC容器</h2><p>什么是IOC容器：IOC容器就是用来管理、创建、装配 Java对象的</p>
<ul>
<li>Spring提供IOC容器实现两种方式<ul>
<li>BeanFactory：IOC容器最基本的实现，是Spring内部的使用接口，不提供开发人员使用，使用懒加载<ul>
<li>特点：加载配置文件的时候不会去创建对象，在获取和使用的时候才去创建</li>
</ul>
</li>
<li>ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用，使用的是即时加载。<ul>
<li>特点：加载配置文件时候就会把在配置文件中的对象进行创建</li>
<li>主要实现类1：ClassPathXmlApplicationContext，参数中配置文件的路径是类路径下的相对路径</li>
<li>主要实现类2：FileSystemXmlApplicationContext，参数中配置文件的路径是磁盘中的绝对路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>好处：</p>
<ul>
<li>最小化应用程序的代码量</li>
<li>应用解耦</li>
<li>支持即时实例化和延迟加载服务</li>
</ul>
<h2 id="什么是Bean"><a href="#什么是Bean" class="headerlink" title="什么是Bean"></a>什么是Bean</h2><p>被Spring 容器管理的Java对象。</p>
<p>由IOC容器实例化，配置，装配和管理。</p>
<h2 id="阐述Spring框架中Bean的生命周期"><a href="#阐述Spring框架中Bean的生命周期" class="headerlink" title="阐述Spring框架中Bean的生命周期?"></a>阐述Spring框架中Bean的生命周期?</h2><ul>
<li>通过构造器创建 bean 实例（无参数构造） </li>
<li>调用set方法设置属性</li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization </li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization </li>
<li>获取创建好的bean实例对象</li>
<li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--
    init-method属性:执行初始化方法
   destroy-method属性：执行销毁方法
--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orders<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.spring5.bean.Orders<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initMethod<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>destroyMethod<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>oName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>手机<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!--配置后置处理器--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myBeanPost<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.spring5.bean.MyBeanPost<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="Spirng支持的bean-scope"><a href="#Spirng支持的bean-scope" class="headerlink" title="Spirng支持的bean scope"></a>Spirng支持的bean scope</h2><ul>
<li>Singleton - 每个Spring IOC 容器仅有一个单实例</li>
<li>Prototype - 每次请求都会产生一个新的实例</li>
<li>Request    - 每一次请求都会产生一个新的实例</li>
<li>Session - 每一次HTTP请求都会产生一个新的实例，并且该bean仅在当前的HTTP请求有效</li>
</ul>
<h2 id="Spring事务管理类型"><a href="#Spring事务管理类型" class="headerlink" title="Spring事务管理类型"></a>Spring事务管理类型</h2><ul>
<li>编程式事务：在此过程中，使用编码的方式管理事务，具有很大的灵活性，但是维护起来非常困难</li>
<li>声明式事务：事务管理与业务代码分离，仅使用注解或基于XML的配置来管理事务</li>
</ul>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>就是在不改变源代码的情况下，在主干功能里面添加新功能，通过CGLIB或者JDK的动态代理来实现</p>
<h2 id="什么是Aspect"><a href="#什么是Aspect" class="headerlink" title="什么是Aspect"></a>什么是Aspect</h2><p>​     Aspect 由 切入点和通知组成，既包含了横切逻辑的定义，也包括了切入点的定义，AOP将切面定义的横切逻辑编织到切面所指定的连接点中。</p>
<h2 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h2><p>特定切入点处的切面所采取的动作就是通知(advice)。</p>
<ul>
<li>before：在切入点方法之前执行，使用@Before注解</li>
<li>Aroud：在切入点方法之前和之后执行，使用@Around注解，必须在代码内指明要通知的方法</li>
<li>After(finally)：在切入点方法之后执行，无论切入点方法正常还是异常，使用@After注解</li>
<li>After Returning：在切入点方法正常执行后执行，使用 @After Returning注解</li>
<li>After Throwing：仅在切入点方法中抛出异常退出时执行，使用 @After Throwing注解</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 *  环绕通知
 * @param proceedingJoinPoint
 * @throws Throwable
 */</span>
<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"pointDemo()"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint proceedingJoinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕之前........."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    proceedingJoinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//被增强的方法执行,如果没有的话，@Before是执行不了的</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕之后........."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="Spring由哪些模块组成"><a href="#Spring由哪些模块组成" class="headerlink" title="Spring由哪些模块组成"></a>Spring由哪些模块组成</h2><ul>
<li>Core module<ul>
<li>Core模块是Spring的核心类库，Spring的所有功能都依赖于该类库，Core主要实现IOC功能，Spring的所有功能都是借助IOC实现的。</li>
</ul>
</li>
<li>Context module<ul>
<li>这个模块扩展了BeanFactory的概念，增加了消息、事件传播以及验证的支持</li>
</ul>
</li>
<li>AOP module<ul>
<li>AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常用的拦截器</li>
</ul>
</li>
<li>DAO module<ul>
<li>对传统的JDBC进行了抽象，还提供了声明性事务。</li>
</ul>
</li>
<li>ORM module<ul>
<li>提供对常用的ORM框架的管理和辅助支持</li>
</ul>
</li>
<li>Web module<ul>
<li>提供了WEB开发的基础集成特性</li>
</ul>
</li>
</ul>
<h2 id="什么是内部Bean"><a href="#什么是内部Bean" class="headerlink" title="什么是内部Bean"></a>什么是内部Bean</h2><p>​    当一个bean仅被用作另一个bean属性时，就被声明为一个内部bean，通常是匿名的，Scope 一般是 prototype</p>
<h2 id="注入java集合"><a href="#注入java集合" class="headerlink" title="注入java集合"></a>注入java集合</h2><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--集合类型属性的注入--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stu<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.spring5.collectiontype.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

   <span class="token comment" spellcheck="true">&lt;!--数组类型属性的注入--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>courses<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>java课程<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>数据结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>数据库<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

   <span class="token comment" spellcheck="true">&lt;!--List类型属性的注入--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>王瀚文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>瀚文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

   <span class="token comment" spellcheck="true">&lt;!--maps类型属性的注入--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maps<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JAVA<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PHP<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>php<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

   <span class="token comment" spellcheck="true">&lt;!--sets--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sets<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>MySQL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>Redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

   <span class="token comment" spellcheck="true">&lt;!--注入List集合类型，值是对象--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>courseList<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>course1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>course2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>

   <span class="token comment" spellcheck="true">&lt;!--注入Map集合类型，值是对象--></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>courseMaps<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>course1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>course2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!--创建多个course对象--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>course1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.spring5.collectiontype.Course<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Spring5框架<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>course2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.whw.spring5.collectiontype.Course<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>MyBatis框架<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="Spring对DAO的支持"><a href="#Spring对DAO的支持" class="headerlink" title="Spring对DAO的支持"></a>Spring对DAO的支持</h2><p>Spring面向DAO屏蔽具体持久化技术之间的差异，使业务层和具体的持久化技术实现解耦。</p>
<h2 id="什么是Spring-MVC"><a href="#什么是Spring-MVC" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h2><p>​    Spring MVC是一个基于Java实现的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错。</p>
<p>优点：</p>
<ul>
<li>支持各种视图技术</li>
<li>与spring框架集成</li>
<li>把一整部分 分成小部分 分开处理</li>
</ul>
<p>Spring MVC的组件</p>
<ul>
<li>前端控制器：DispatcherServlet<ul>
<li>作用：接收请求，响应结果，相当于转发器，减少了其他部分之间的耦合度</li>
</ul>
</li>
<li>处理器映射器 HandlerMapping<ul>
<li>作用：根据请求的URL来查找Handler</li>
</ul>
</li>
<li>处理器适配器 HandlerAdapter<ul>
<li>作用：执行Handler</li>
</ul>
</li>
<li>处理器 Handler<ul>
<li>也就是 controller层</li>
</ul>
</li>
<li>视图解析器 ViewResolver<ul>
<li>作用：进行视图解析，根据视图逻辑名解析为真正的视图</li>
</ul>
</li>
</ul>
<h2 id="SpringMVC的原理"><a href="#SpringMVC的原理" class="headerlink" title="SpringMVC的原理"></a>SpringMVC的原理</h2><ul>
<li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求</li>
<li>DispatcherServlet收到请求后，将根据请求的信息和HandlerMpping找到处理该请求的Handler，最后以HandlerExecutionChain对象的形式返回给 DispatcherServlet</li>
<li>DispatcherServlet根据获得的Handler，选择合适的 HandlerAdapter</li>
<li>HandlerAdapter 调用具体的处理器 Handler</li>
<li>Controller完成对用户请求的处理之后会返回一个ModelAndView对象给DispatcherServlet，ModelAndView包含了数据模型以及相应的视图的信息</li>
<li>ModelAndView的视图是逻辑视图，DispatcherServlet借助于视图解析器ViewResolver完成从逻辑视图到真实视图对象的解析工作。</li>
<li>得到真正的视图View后，DispatcherServlet利用视图对象对模型数据进行渲染</li>
<li>DispatcherServlet响应用户</li>
</ul>
<h2 id="MVC设计模式的好处"><a href="#MVC设计模式的好处" class="headerlink" title="MVC设计模式的好处"></a>MVC设计模式的好处</h2><p>​    MVC是一种设计模式，模型 model，视图 View，控制器 Controller。三层架构的设计模式用于实现前端页面的展现和后端业务数据处理的分离。</p>
<h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>​    注解本质是一个继承了 Annotation 的特殊接口，具体实现类是 Java运行时生成的动态代理类，通过反射获取注解时，返回的是 java运行时生成的动态代理对象，通过代理对象调用注解中的方法，会最终调用 AnnotationInvocationHandler的invoke方法，该方法会从 memberValues这个map中索引出对应的值(键是我们注解方法名称，值就是该属性当初被赋上的值)，而memberValues的来源是java常量池</p>
<h2 id="Controller的作用"><a href="#Controller的作用" class="headerlink" title="@Controller的作用"></a>@Controller的作用</h2><p>​    Controller类负责处理 DispatcherServlet分发的请求，把用户请求的数据经过业务逻辑处理之后封装成一个Model，然后返回前端控制器。</p>
<p>​    用 @Controller 注解标注的类即为 Controller对象，处理器将会扫描使用了@Controller的类的方法，并检测方法是否使用了@RequestMapping注解，只有使用了@RequestMapping之后才是真正请求的处理器，@Controller只是定义了一个控制类。</p>
<h2 id="解决POST请求参数的乱码问题"><a href="#解决POST请求参数的乱码问题" class="headerlink" title="解决POST请求参数的乱码问题"></a>解决POST请求参数的乱码问题</h2><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置springMVC的编码过滤器--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>forceResponseEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="SpringMVC和SpringBoot的异常处理"><a href="#SpringMVC和SpringBoot的异常处理" class="headerlink" title="SpringMVC和SpringBoot的异常处理"></a>SpringMVC和SpringBoot的异常处理</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span> <span class="token comment" spellcheck="true">//将当前类标识为异常处理的组件</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionController</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//@ExceptionHandler用于设置所标识方法处理的异常</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>ArithmeticException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//ex表示当前请求处理中出现的异常对象</span>
    <span class="token keyword">public</span> String <span class="token function">handleArithmeticException</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">,</span> Model model<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"ex"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"error"</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h2><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandle：控制器方法执行之后执行postHandle()</p>
<p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//返回false表示拦截，返回ture表示放行</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>【<strong>必须得在xml中配置才可以使用</strong>】</p>
<h2 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h2><p>​    SpringBoot是用来简化spring 应用的初始搭建以及开发过程的，只需要在properties配置文件中配置少量的信息就可以了，提供了各种启动器，用main方法就可以运行。还内嵌了Tomcat，直接运行jar包就可以启动项目。</p>
<p>好处：</p>
<ul>
<li>减少开发时间，</li>
<li>使用配置类可以减少XML</li>
<li>避免版本冲突</li>
<li>不用配置Tomcat，因为已经内嵌了</li>
</ul>
<p>缺点：</p>
<ul>
<li>报错时很难定位</li>
</ul>
<p>SpringBoot支持 thymeleaf、freemarker两个前端模板</p>
<p>开启springboot，在pom文件中添加如下父类</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>

它还有一个父类
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>
</code></pre>
<p>核心配置：</p>
<ul>
<li><p>独立运行Spring项目</p>
</li>
<li><p>内嵌Tomcat</p>
</li>
<li><p>提供starter，简化maven配置</p>
</li>
<li><p>自配配置Spring Bean</p>
</li>
</ul>
<h2 id="SpringBoot的核心注解是哪个-它主要由哪几个注解组成？"><a href="#SpringBoot的核心注解是哪个-它主要由哪几个注解组成？" class="headerlink" title="SpringBoot的核心注解是哪个?它主要由哪几个注解组成？"></a>SpringBoot的核心注解是哪个?它主要由哪几个注解组成？</h2><p>核心注解是 @SpringBootApplication</p>
<p>由</p>
<ul>
<li>@SpringBootConfiguration：实现配置文件的功能</li>
<li>@EnableAutoConfiguration：开启自动配置的功能，也可以关闭某个自动配置项</li>
<li>@ComponentScan：组件扫描</li>
</ul>
<h2 id="bootstrap-yaml-和-application-yaml有什么区别"><a href="#bootstrap-yaml-和-application-yaml有什么区别" class="headerlink" title="bootstrap.yaml 和  application.yaml有什么区别"></a>bootstrap.yaml 和  application.yaml有什么区别</h2><p>bootstrap.yml 和 application.yml 都可以用来配置参数。</p>
<p>bootstrap.yml 用来配置系统级别的一些参数配置，这些参数一般是不会变动的。一旦bootStrap.yml 被加载，内容就不会被覆盖了。还用于一些加密/解密的场景</p>
<p>application.yml 主要用于SringBoot项目的自动化配置</p>
<p>application.yml 不能通过 @PropertySource 读取</p>
<h2 id="SpringBoot配置加载顺序"><a href="#SpringBoot配置加载顺序" class="headerlink" title="SpringBoot配置加载顺序"></a>SpringBoot配置加载顺序</h2><p>properties — &gt;  YAML —-&gt; 系统环境变量 —&gt; 命令行参数</p>
<p>通过 @Value、@ConfigurationProperties 、@PropertySource可以读取配置文件</p>
<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>​    注解@EnableAutoConfiguration有个功能是一启动就去寻找Starter包下的resources/META-INF/spring.factories文件给容器中加载的所有配置类，然后根据导入的启动器开启自动配置项和配置文件中大量的 @Conditionalxxx 的注解判断是否要将Bean注入到容器中，进而完成自动配置。</p>
<h2 id="SpringBoot中的Starters"><a href="#SpringBoot中的Starters" class="headerlink" title="SpringBoot中的Starters"></a>SpringBoot中的Starters</h2><p>​    Starters是启动器，包含了一系列可以集成到应用里面的依赖包，实现了一站式集成Spring及其他技术，不需要到处找示例代码和依赖包</p>
<p>常见的启动器：</p>
<ul>
<li>spring-boot-starter-web</li>
<li>spring-boot-starter-Redis</li>
<li>mybatis-spring-boot-starter</li>
</ul>
<h2 id="SpringBoot支持哪些日志框架"><a href="#SpringBoot支持哪些日志框架" class="headerlink" title="SpringBoot支持哪些日志框架"></a>SpringBoot支持哪些日志框架</h2><p>支持 Logging、log4j2，LogBack，默认是 LogBack </p>
<p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p>
<ol>
<li> 将系统中其他日志框架先排除出去；</li>
<li>用中间包来替换原有的日志框架；</li>
<li>导入slf4j其他的实现</li>
</ol>
<h2 id="运行SpringBoot有哪几种方式"><a href="#运行SpringBoot有哪几种方式" class="headerlink" title="运行SpringBoot有哪几种方式"></a>运行SpringBoot有哪几种方式</h2><ul>
<li>打成 Fat jar包，直接 java -jar 运行</li>
<li>直接执行main()</li>
</ul>
<h2 id="SpringBoot中的监视器"><a href="#SpringBoot中的监视器" class="headerlink" title="SpringBoot中的监视器"></a>SpringBoot中的监视器</h2><p>​    Springboot actuator是Spring启动框架中的重要功能之一。Spring boot监视器可帮助访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p>
<h2 id="SpringBoot可以兼容老的Spring项目吗"><a href="#SpringBoot可以兼容老的Spring项目吗" class="headerlink" title="SpringBoot可以兼容老的Spring项目吗"></a>SpringBoot可以兼容老的Spring项目吗</h2><p>使用 @ImportResource 注解导入老的Spring项目的xml配置文件</p>
<h2 id="各服务间通信，对Restful-和-RPC这两种方式如何做选择"><a href="#各服务间通信，对Restful-和-RPC这两种方式如何做选择" class="headerlink" title="各服务间通信，对Restful 和 RPC这两种方式如何做选择"></a>各服务间通信，对Restful 和 RPC这两种方式如何做选择</h2><p>建议使用 Restful，可以在不同的语言之间实现服务通讯</p>
<h2 id="Spring-Caceh三种常见缓存注解"><a href="#Spring-Caceh三种常见缓存注解" class="headerlink" title="Spring Caceh三种常见缓存注解"></a>Spring Caceh三种常见缓存注解</h2><ul>
<li>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</li>
<li>@CachePut，使用@CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入缓存中。</li>
<li>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</li>
</ul>
<h2 id="Spring，SpringBoot和Spring-Cloud的关系"><a href="#Spring，SpringBoot和Spring-Cloud的关系" class="headerlink" title="Spring，SpringBoot和Spring Cloud的关系"></a>Spring，SpringBoot和Spring Cloud的关系</h2><p>Spring最初最核心的两个功能就是 IOC 和 AOP，在这两个功能上不断的发展，才有了Spring事务和MVC等产品</p>
<p>SpringBoot是在spring的基础上发展而来的，为了更容易的使用 String</p>
<p>SpringCloud是一系列框架的集合，利用SpringBoot的开发便利简化了分布式系统基础设施的开发，比如服务发现注册，配置中心，消息总线等。</p>
<h2 id="是否可以在SpringBoot中覆盖或替换嵌入式Tomcat"><a href="#是否可以在SpringBoot中覆盖或替换嵌入式Tomcat" class="headerlink" title="是否可以在SpringBoot中覆盖或替换嵌入式Tomcat"></a>是否可以在SpringBoot中覆盖或替换嵌入式Tomcat</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring‐boot‐starter‐web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- 排除 Tomcat依赖 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!‐‐引入Jetty‐‐</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jetty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="如何在SpringBoot启动的时候运行一些特定的代码"><a href="#如何在SpringBoot启动的时候运行一些特定的代码" class="headerlink" title="如何在SpringBoot启动的时候运行一些特定的代码"></a>如何在SpringBoot启动的时候运行一些特定的代码</h2><p>​    实现接口 ApplicationRunner 和  CommandLineRunner 这两个接口，实现方式一样，都是只提供了一个run()，在加入到IOC容器中就行了。</p>
<h2 id="SpringBoot-2-X有什么新特性-与1-X有什么区别"><a href="#SpringBoot-2-X有什么新特性-与1-X有什么区别" class="headerlink" title="SpringBoot 2.X有什么新特性?与1.X有什么区别"></a>SpringBoot 2.X有什么新特性?与1.X有什么区别</h2><ul>
<li>依赖JDK版本升级为 8</li>
<li>支持 spring 5+，Tomcat 8.5+，Thymeleaf3+</li>
<li>响应式Spring编程</li>
</ul>
<h2 id="什么是Spring-Profiles"><a href="#什么是Spring-Profiles" class="headerlink" title="什么是Spring Profiles"></a>什么是Spring Profiles</h2><p>​    Spring Profiles 允许用户根据配置文件中的环境来注册bean，当应用程序是开发环境时，只有某些bean可以加载，而在生成环境中，其他的bean可以被加载。也就是不同的环境加载不同的配置</p>
<p>​    方法1：创建application-test.yaml 或者 application-dev.yaml 等配置文件，然后再主配置文件application.yaml启用对应的配置文件就行</p>
<p>​    方法2：启动的时候添加参数  java -jar  xxx.jar –spring.profiles.active=test/productor</p>
<h2 id="什么是-Spring-Batch"><a href="#什么是-Spring-Batch" class="headerlink" title="什么是 Spring Batch"></a>什么是 Spring Batch</h2><p>​    Spring Batch 提供了用于处理大量记录的可重用函数，包括事务，作业处理统计等，它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现高批量和高性能批处理作业。简单以及复杂的大批量批处理作业以高度可扩展的方式利用框架处理重要大量的信息。</p>
<h2 id="什么是-CSRF攻击"><a href="#什么是-CSRF攻击" class="headerlink" title="什么是 CSRF攻击"></a>什么是 CSRF攻击</h2><p>​    CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。</p>
<h2 id="什么是WebSockets"><a href="#什么是WebSockets" class="headerlink" title="什么是WebSockets"></a>什么是WebSockets</h2><p>​    WebSocket 是一个持久化的协议并且基于HTTP协议完成一部分握手，它最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。</p>
<p>​    从初始连接使用HTTP，然后将此连接升级为套接字的连接，然后这个连接用于未来所有的通信</p>
<h2 id="如何给静态变量赋值"><a href="#如何给静态变量赋值" class="headerlink" title="***如何给静态变量赋值"></a>***如何给静态变量赋值</h2><p>如果是给静态变量赋值,直接使用@value()，不起作用</p>
<p>要赋值，需要提供此属性的set方法，在set方法上使用@Value(“${user.name}”)</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> String userName；

<span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&amp;#123;user.name&amp;#125;"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserName</span><span class="token punctuation">(</span>String userName<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   userName <span class="token operator">=</span> userName；
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="SpringBoot-事务的使用"><a href="#SpringBoot-事务的使用" class="headerlink" title="SpringBoot 事务的使用"></a>SpringBoot 事务的使用</h2><p>在启动类上使用 @EnableTransactionManagement开启事务之后，在service方法上添加注解 @Transactional</p>
<h2 id="SpringBoot-打成的jar包和普通的jar有什么区别"><a href="#SpringBoot-打成的jar包和普通的jar有什么区别" class="headerlink" title="SpringBoot 打成的jar包和普通的jar有什么区别"></a>SpringBoot 打成的jar包和普通的jar有什么区别</h2><p>​    SpringBoot项目最终打包成的jar是可执行jar ，这种jar可以直接通过 java -jar xxx.jar 命令来运行，这种jar 不可以作为普通的jar被其他项目依赖，即使依赖了也无法使用其中的类。<br>​    SpringBoot的jar无法被其他项目依赖，主要还是他和普通jan的结构不同。普通的jar包，解压后直接就是包名，包里就是我们的代码，而SpringBoot 打包成的可执行jar解压后，在\BOOT-INF\classes目录下才是我们的代码,因此无法被直接引用。如果非要引用，可以在pom.xml 文件中增加配置，将SpringBoot项目打包成两个jar ，一个可执行，一个可引用。</p>
<h2 id="什么是FreeMarker模板"><a href="#什么是FreeMarker模板" class="headerlink" title="***什么是FreeMarker模板?"></a>***什么是FreeMarker模板?</h2><p>​    FreeMarker是一个基于Java 的模板引擎，最初专注于使用MVC软件架构进行动态网页生成。使用Freemarker, 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后使用freemarker可以将这些结合起来，给出最终的输出页面。</p>
<h2 id="spring-boot-starter-parent有什么用"><a href="#spring-boot-starter-parent有什么用" class="headerlink" title="spring-boot-starter-parent有什么用"></a>spring-boot-starter-parent有什么用</h2><ul>
<li>定义java编译器版本为8</li>
<li>使用 UTF-8格式编码</li>
<li>继承了 spring-boot-dependencies，这个里面定义了依赖的版本</li>
<li>通过profile,定义的不同环境的配置文件，例如application-dev.properties 和 application-dev.yml.</li>
</ul>
<h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>​    swagger可以用来快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p>
<h2 id="什么是ZooKeeper"><a href="#什么是ZooKeeper" class="headerlink" title="什么是ZooKeeper"></a>什么是ZooKeeper</h2><p>​    ZooKeeper 是一个分布式应用程序协调服务，它是集群的管理者，监视这集群中各个节点的状态，根据节点提交的反馈来执行下一步操作，最终将高效功能稳定的系统提供给用户。</p>
<p>​    默认端口2181</p>
<p>​    客户端的读请求可以被集群中的任意一台机器处理，对于写请求，会先给leader，leader写完之后在通知follower，随着集群的增多，读请求的吞吐量会提高但是写请求的吞吐量会下降</p>
<h2 id="ZooKeeper-提供了两个东西"><a href="#ZooKeeper-提供了两个东西" class="headerlink" title="ZooKeeper 提供了两个东西"></a>ZooKeeper 提供了两个东西</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>ZooKeeper 提供了一个多层级的节点 znode，文件系统中只有文件节点可以存放数据。ZooKeeper 为了保证高吞吐和低延迟，在内存中维护了这个数组的目录结构，这也使得 ZooKeeper  不能存放大量的数据，每个节点的数据上限为 1MB。</p>
<p>​    四种类型的 znode</p>
<ul>
<li>PERSISTENT：持久化目录节点，客户端 和 ZooKeeper 断开连接后，该节点依旧存在。</li>
<li>PERSISTENT_SEQUENTIAL：持久化顺序编号目录节点，客户端 和 ZooKeeper 断开连接后，该节点依旧存在。ZooKeeper 给该节点名称进行顺便编号</li>
<li>EPHEMERAL：临时目录结点，客户端 和 ZooKeeper 断开连接后，该节点被删除。</li>
<li>EPHEMERAL_SEQUENTIAL：临时顺序编号目录节点，客户端 和 ZooKeeper 断开连接后，该节点被删除。ZooKeeper 给该节点名称进行顺便编号</li>
</ul>
<h3 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h3><p>​    client端会对某个znode建立一个 watcher事件，当 znode发生变化时，这些 client会收到 ZooKeeper 的通知，然后 client可以根据 znode变化来做出业务上的改变等。</p>
<h2 id="ZooKeeper-做了什么"><a href="#ZooKeeper-做了什么" class="headerlink" title="ZooKeeper 做了什么"></a>ZooKeeper 做了什么</h2><h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>​    通过指定的名字来获取资源或者服务的地址，利用 ZooKeeper  创建一个全局的路径，这个路径作为一个名字指向集群提供服务的地址。</p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>​    程序部署在不同的机器上，将程序的配置信息放在 zk的 znode下，当有znode发生改变时，可以通过改变 zk 中某个目录节点的内容，利用 watcher通知给各个客户端</p>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>两方面</p>
<ul>
<li><p>是否有机器加入和退出</p>
<ul>
<li>所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息，一旦有机器挂掉，该机器与zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知:某个兄弟目录已经被删除。新机器加入，所有机器都收到通知</li>
</ul>
</li>
<li><p>选举master</p>
<ul>
<li>所有机器创建临时顺序编号目录节点，每次选取标号最小的机器作为master就行。</li>
</ul>
</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>锁服务分两类</p>
<h4 id="保持独占"><a href="#保持独占" class="headerlink" title="保持独占"></a>保持独占</h4><p>​    将 ZooKeeper 上的一个znode看做是一把锁，通过create的方式来实现，所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户也即用于了这把锁，用完删除掉自己创建的结点就可以释放锁</p>
<h4 id="控制时序"><a href="#控制时序" class="headerlink" title="控制时序"></a>控制时序</h4><p>​    /distribute_lock已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，序号最小的获得锁，用完删除</p>
<p>==获得分布式锁流程==</p>
<p>​    在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。</p>
<p>​    接着调用 getChildren(“locker”) 来获取 locker 下面的所有节点，客户端获取到所有的子节点 之后，如果发现自己创建的结点并非 locker 所有子节点中最小的，说明自己还没有获取到锁，如果发现自己创建的结点在所有创建的子节点中序号最小，那么就认为获取到了锁。此时客户端需要找到比自己小一号的那个节点，对其注册事件监听器，当这个被关注的节点删除后，客户点的watcher会收到通知，此时再次判断自己创建的节点是否是序号最小的，如果是则获取锁，不是就接着重复上述步骤。</p>
<h3 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h3><p>两种类型队列</p>
<ul>
<li>同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达<ul>
<li>实现方法：在约定目录下创建临时节点，监听节点数目是否是要求数目</li>
</ul>
</li>
<li>队列按照 FIFO 方式进行入队和出队操作<ul>
<li>实现方法： 和分布式锁服务中的控制时序场景一致，入列有编号，出列按编号。在特定的目录下创建PERSISENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序号最小的节点用于消费，此场景下 Zookeeper 的 zonde用于消息存储，znode存储的数据就是消息队列中的消息内容，按顺序取出就行，由于创建的结点是持久化的，所以不必担心队列消费的丢失问题</li>
</ul>
</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>​    首先建立znode节点，并建立监听器监视znode子节点的状态（用于在服务器增添时及时同步当前集群中服务器列表）。在每个服务器启动时，在znode节点下建立子节点（可以用服务器地址命名）,并在对应的子节点下存入服务器的相关信息。这样，我们在zookeeper服务器上可以获取当前集群中的服务器列表及相关信息，可以自定义一个负载均衡算法，在每个请求过来时从zookeeper服务器中获取当前集群服务器列表，根据算法选出其中一个服务器来处理请求。</p>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>​    发布者将数据发布到ZooKeeper上一个或多个节点上，订阅者从中订阅数据，从而动态获取数据的目的，实现配置信息的集中式管理和数据动态更新。</p>
<p>两种设计模式</p>
<ul>
<li>推(Push) :服务端主动推数据给所有定于的客户端。</li>
<li>拉(Pull):   客户端主动发请求来获取最新数据.</li>
</ul>
<h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><p>ZooKeeper 要在所有机器之间做数据复制，有以下好处</p>
<ul>
<li>容错：一个节点出错，不至于让整个系统停止工作，别的结点可以接管它的工作；</li>
<li>提高系统的扩展能力：把负载分布在多个节点上，或者增加节点来提高系统的负载能力</li>
</ul>
<p>​    ZooKeeper 采用的方式是写任意，也就是对数据的修改可以提交给任意的结点。通过增加机器，它的读吞吐能力和响应能力扩展性非常好。而写的吞吐量肯定下降(这也是它建立observer的原因)，而响应能力是取决于具体的实现方式，是延迟复制的保持最终一致性，还是立即复制的快速响应。</p>
<h2 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h2><p>leader：事务请求的唯一调度和处理者，保证集群事务处理的顺序性</p>
<p>follower：参与leader的选举投票，处理客户端的读写请求</p>
<p>observer：处理客户端的读写请求，不参与任何形式的投票</p>
<h2 id="ZooKeeper-下server的工作状态"><a href="#ZooKeeper-下server的工作状态" class="headerlink" title="ZooKeeper 下server的工作状态"></a>ZooKeeper 下server的工作状态</h2><p>LOOKING：寻找leader的状态</p>
<p>FOLLOWING：跟随者状态</p>
<p>LEADING：领导者</p>
<p>OBSERVING：观察者状态</p>
<h2 id="ZooKeeper-工作原理"><a href="#ZooKeeper-工作原理" class="headerlink" title="ZooKeeper 工作原理"></a>ZooKeeper 工作原理</h2><p>​    ZooKeeper 的核心是原子广播，这个机制保证了各个server之间的同步，实现这个机制的协议叫做Zab协议。Zab协议有两种模式，恢复模式、广播模式，当服启动或者在领导者崩溃之后，Zab就进入了恢复模式，当领导者选出来且大多数Server完成了和Leader的状态同步以后，恢复模式就结束了，状态同步保证了leader和Server具有相同的系统状态。</p>
<h2 id="恢复模式"><a href="#恢复模式" class="headerlink" title="恢复模式"></a>恢复模式</h2><p>包含选主模式和同步模式</p>
<h3 id="选主模式"><a href="#选主模式" class="headerlink" title="选主模式"></a>选主模式</h3><p>有两种</p>
<p>basic paxos</p>
<ul>
<li>选举线程由发现leader不能用的server发起选举的线程担任，主要是对投票结果进行统计，并选出推荐的Server</li>
<li>选举线程首先向所有Server发起一次询问</li>
<li>选举线程收到回复后，获取对方的id，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息，并将这些信息存储到当前选举的投票记录表中</li>
<li>收到所有server回复后，计算出zxid最大的server，并将这个server相关信息设置成下一次要投票的server</li>
<li>线程将当前的zxid最大的server设置为当前server要推荐的Leader，如果此时获胜的server获得 n/2 + 1 的server票数，设置当前推荐server为leader</li>
</ul>
<p>fast paxos</p>
<p>​    fast paxos流程是在选举过程中，某Server首先向所有Server 提议自己要成为leader，当其它Server 收到提议以后，解决epoch和zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader.</p>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><p>选完leader之后，就进入同步过程</p>
<ul>
<li>leader等待server 连接</li>
<li>Follower连接leader，将最大的zxid发送给leader</li>
<li>Leader根据follower的zxid确定同步点</li>
<li>完成同步后通知follower已经成为uptodate状态</li>
<li>Follower收到成为uptodate的消息后，又可以重新接收client的请求进行服务了</li>
</ul>
<h2 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h2><p>对写请求进行广播</p>
<p>​        客户端发送请求给 Leader节点，Leader节点自己先进行写操作，完了之后通知 Follower节点进行写，写完之后  Follower节点回应Leader节点。只要超过半数的服务器写完，Leader节点就可以通知客户端请求已经完成，剩下的 Follower节点 在进行写操作。</p>
<p>​        客户端发送请求给 Follower节点 ，Follower节点转发给Leader节点，Leader节点自己进行写操作，完了之后通知 Follower节点 进行写操作，Follower节点 写完之后回应 Leader节点。只要超过半数的 服务器写操作完成，Leader节点就通知那个接收请求的Follower节点，让其通知客户端写操作完成。</p>
<h2 id="为什么要有leader"><a href="#为什么要有leader" class="headerlink" title="为什么要有leader"></a>为什么要有leader</h2><p>​    在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行就可以，其他的集群可以共享这个结果，这样可以大大减少重复计算，提高性能。</p>
<p>​    这时候当一个server 加入ZooKeeper服务中，它会在恢复模式下启动，发现leader, 并和leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper.服务一直维持在Broadcast状态，直到leader崩溃了或者leader 失去了大部分的followers 支持。</p>
<h2 id="ZooKeeper-保证事务顺序的一致性"><a href="#ZooKeeper-保证事务顺序的一致性" class="headerlink" title="ZooKeeper 保证事务顺序的一致性"></a>ZooKeeper 保证事务顺序的一致性</h2><p>​    ZooKeeper 采用了递增的事务ld来标识，所有的proposal(提议)都在被提出的时候加上了zxid, zxid实际上是一个64位的数字,高32位是epoch(时期;纪元; ,世:新时代)用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位从0开始递增计数。同一任期内，ZXID是连续的，每个结点又都保存着自身最新生效的ZXID，通过对比新提案的ZXID与自身最新ZXID是否相差“1”，来保证事务严格按照顺序生效的。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p>
<h2 id="Zookeeper-Watcher机制"><a href="#Zookeeper-Watcher机制" class="headerlink" title="Zookeeper Watcher机制"></a>Zookeeper Watcher机制</h2><p>​    Zookeeper 允许客户端向服务端的某个Znode注册一个 Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher做出业务上的改变</p>
<p>特性：</p>
<ul>
<li>一次性</li>
<li>客户端串行执行：客户端watcher回调的过程是一个串行同步的过程</li>
<li>轻量：通知只会告诉客户端发生了改变，而不会说明事件的具体内容</li>
</ul>
<p>为什么是一次性的原因</p>
<p>​    如果服务端变动频繁，每次变动都要通知客户端，给服务器造成了很大的压力，而且在很多情况下，不需要知道服务端的每一次变动，只需要得到最新的数据即可</p>
<p>​    </p>
<h2 id="ACL访问控制列表"><a href="#ACL访问控制列表" class="headerlink" title="ACL访问控制列表"></a>ACL访问控制列表</h2><p>​    ZooKeeper 利用ACL策略控制节点的访问权限，如节点数据读写，节点创建，节点删除，读取子节点列表，设置节点权限等。</p>
<p>有三个纬度</p>
<ul>
<li>权限模式Scheme<ul>
<li>IP：根据IP地址进行权限控制</li>
<li>Digest：是最常用的权限控制模式，类似于 username:password 形式的权限标识进行权限配置，它对应的id为 username:BASE64(SHA1(password))</li>
<li>World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识 world:anyone</li>
<li>super：超级用户</li>
</ul>
</li>
<li>授权对象<ul>
<li>指的是权限赋予的一个指定实体</li>
</ul>
</li>
<li>权限Permission<ul>
<li>CREATE：创建权限</li>
<li>DELETE：删除权限</li>
<li>READ：读权限</li>
<li>WRITE：写权限</li>
<li>ADMIN：管理权限，允许授权对象对该数据节点进行ACL相关设置操作</li>
</ul>
</li>
</ul>
<h2 id="chroot特性"><a href="#chroot特性" class="headerlink" title="chroot特性"></a>chroot特性</h2><p>​    就是允许每个客户端为自己设置一个命名空间，如果一个客户端设置了Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令的语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls  路径</td>
<td>使用 ls 命令来查看当前 znode 的子节点 <br />-w： 监听子节点变化 <br />-s :    显示详细信息</td>
</tr>
<tr>
<td>create</td>
<td>普通创建节点<br />-s  含有序列节点 <br />-e  临时节点</td>
</tr>
<tr>
<td>get 路径</td>
<td>获得节点的值<br/> -w  监听节点内容变化<br /> -s  显示详细信息</td>
</tr>
<tr>
<td>set</td>
<td>设置节点具体值</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete</td>
<td>删除节点</td>
</tr>
<tr>
<td>deleteall</td>
<td>递归删除节点</td>
</tr>
</tbody></table>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><ul>
<li>C：Consistency 一致性，数据在多个副本之间是否能够保持一致性的特性。</li>
<li>A：Availability可用性，系统服务一直处于可用状态，对每个请求总是在指定的时间返回结果。</li>
<li>P：partition tolerance 分区容错性，遇到分区网络故障时，仍能对外提供一致性或者可用性的服务</li>
</ul>
<p>只能同时满足CP或者AP</p>
<h2 id="并发编程三元素"><a href="#并发编程三元素" class="headerlink" title="并发编程三元素"></a>并发编程三元素</h2><p>也就是JMM的三个特性</p>
<ul>
<li>原子性<ul>
<li>原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部不执行</li>
</ul>
</li>
<li>可见性<ul>
<li>多个线程操作一个共享变量时，其中的一个线程对变量进行修改后，其他的线程是可以立即看到这个修改的结果的，可以通过synchronized或者Lock或者volatile实现可见性</li>
</ul>
</li>
<li>有序性<ul>
<li>程序的执行顺序按照代码的先后顺序来执行</li>
</ul>
</li>
</ul>
<h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p>​    多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务</p>
<h2 id="为什么要有多线程"><a href="#为什么要有多线程" class="headerlink" title="为什么要有多线程"></a>为什么要有多线程</h2><p>优点：</p>
<ul>
<li>发挥多核CPU的优势</li>
<li>防止阻塞：多个线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其他任务的执行</li>
<li>方便业务的拆分，提升应用性能</li>
</ul>
<p>缺点：</p>
<ul>
<li>上下文切换消耗资源<ul>
<li>当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</li>
</ul>
</li>
<li>线程安全问题</li>
<li>死锁</li>
</ul>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ul>
<li>继承Thread类</li>
<li>通过runnable接口</li>
<li>通过Callable接口</li>
<li>通过线程池</li>
</ul>
<h2 id="创建三种线程方式的对比"><a href="#创建三种线程方式的对比" class="headerlink" title="创建三种线程方式的对比"></a>创建三种线程方式的对比</h2><ol>
<li>采用 Runnable、Callable接口的方式创建多线程</li>
</ol>
<p>优势:</p>
<p>​    线程只是实现了接口，还可以继承其他的类</p>
<p>​    多个线程可以共享一个target对象，因为不管你创建了几个Thread对象，它的参数都是  Runnable或者Callable的实现类，最主要的是<strong>Thread类的start() 方除了启动线程的功能外，还有调用当前线程内的run()或者call()方法的功能</strong></p>
<p>缺点：</p>
<p>编程稍微复杂，而且如果要访问当前线程，必须使用 Thread.currentThread() 方法。</p>
<ol start="2">
<li>继承Thread类的方式创建多线程</li>
</ol>
<p>优势：</p>
<p>​    编程简单，访问当前线程使用 this就可以</p>
<p>缺点：</p>
<p>​    继承了 Thread之后就不能继承其他类了</p>
<h2 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h2><ul>
<li><p>Runnable的方法时 run()，Callable的方法call()</p>
</li>
<li><p>Callable有返回值，runnable没有</p>
</li>
<li><p>Callable能抛异常，runnable没有</p>
</li>
<li><p>Callable有泛型，runnable没有</p>
</li>
<li><p>使用Callable创建线程，需要一个Futuer对象，它可以返回值。在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象来完成，当主线程将来需要时，就可以通过Future对象的get()获得后台作业的计算结果或者执行状态。</p>
</li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>新建：当线程对象创建后，就进入了新建状态。</p>
<p>就绪：当调用线程对象的start()时，线程就进入了就绪状态，等待CPU的调度</p>
<p>运行：当CPU开始调度处于就绪状态的线程时，此线程才得以真正的执行</p>
<p>阻塞：处于运行状态的线程由于某些原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入就绪                         状态，才有机会再次被CPU调用以进入到运行状态。</p>
<ul>
<li>等待阻塞：运行状态中的线程执行wait()方法， 使本线程进入到等待阻塞状态</li>
<li>同步阻塞：线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，就会进入同步阻塞</li>
<li>其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
<p>死亡：线程执行完或者因为异常退出了run()方法，该线程结束生命周期</p>
<h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>​    线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。</p>
<p>好处：</p>
<p>​    重用线程，减少开销</p>
<p>​    提高响应速度</p>
<p>​    有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多的资源竞争和堵塞</p>
<p>创建线程池的方式</p>
<ul>
<li>newCacheThreadPool：创建一个可缓存线程池，遇强则强</li>
<li>newFixedThreadPool：创建一个固定线程的线程池</li>
<li>newScheduleThreadPool：支持定时和周期性任务执行</li>
<li>newSingleThreadPool：创建一个单线程的线程池</li>
</ul>
<h2 id="常用的并发工具类"><a href="#常用的并发工具类" class="headerlink" title="常用的并发工具类"></a>常用的并发工具类</h2><p>CountDownLatch</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。
 * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。
 * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，
 * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。
 *
 * 解释：所有同学陆续离开教室后管理员才可以关门。
 *
 * A主线程必须要等前面的线程完成全部工作后，自己才能开干
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"管理员锁门"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t号离开教室"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计数器 -1</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//执行结果</span>
<span class="token number">0</span>    号离开教室
<span class="token number">2</span>    号离开教室
<span class="token number">1</span>    号离开教室
<span class="token number">4</span>    号离开教室
<span class="token number">3</span>    号离开教室
<span class="token number">5</span>    号离开教室
<span class="token number">6</span>    号离开教室
管理员锁门
</code></pre>
<p>CyclicBarrier </p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 *   CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。
 *  它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，然后执行CyclicBarrier构造器里面的线程
 *  接着所有被屏障拦截的线程才会继续执行。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*****召唤神龙，神龙打败敌人*****"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> trmpInt <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t收集到第:"</span> <span class="token operator">+</span> trmpInt <span class="token operator">+</span> <span class="token string">"颗龙珠"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"释放第"</span> <span class="token operator">+</span> trmpInt <span class="token operator">+</span> <span class="token string">" 颗龙珠"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//执行结果</span>
<span class="token number">1</span>    收集到第<span class="token operator">:</span><span class="token number">1</span>颗龙珠
<span class="token number">6</span>    收集到第<span class="token operator">:</span><span class="token number">6</span>颗龙珠
<span class="token number">7</span>    收集到第<span class="token operator">:</span><span class="token number">7</span>颗龙珠
<span class="token number">5</span>    收集到第<span class="token operator">:</span><span class="token number">5</span>颗龙珠
<span class="token number">4</span>    收集到第<span class="token operator">:</span><span class="token number">4</span>颗龙珠
<span class="token number">3</span>    收集到第<span class="token operator">:</span><span class="token number">3</span>颗龙珠
<span class="token number">2</span>    收集到第<span class="token operator">:</span><span class="token number">2</span>颗龙珠
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>召唤神龙，神龙打败敌人<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
释放第<span class="token number">2</span> 颗龙珠
释放第<span class="token number">6</span> 颗龙珠
释放第<span class="token number">1</span> 颗龙珠
释放第<span class="token number">3</span> 颗龙珠
释放第<span class="token number">4</span> 颗龙珠
释放第<span class="token number">5</span> 颗龙珠
释放第<span class="token number">7</span> 颗龙珠
</code></pre>
<p>Semaphore</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 *
 * 在信号量上定义两种操作：
 * acquire(获取) 当一个线程调用acquire操作时，要么通过成功获取信号量(信号量减1)，
 *               要么一直等下去，直到有线程释放信号量，或超时
 * release(释放) 实际上会将信号量的值加1，然后唤醒等待的线程。
 *
 * 信号量主要用于两个目的，一个是用于多个共享的互斥资源，另一个是用于并发线程数的控制
 *
 * 引申：多线程抢占一个资源，抢到的占用20s
 *    答：把资源类改为1(二元信号量)，时间改为20s即可。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模拟资源类，三个车位</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>

            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t抢到了车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t离开了车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//执行结果</span>
<span class="token number">1</span>    抢到了车位
<span class="token number">3</span>    抢到了车位
<span class="token number">2</span>    抢到了车位
<span class="token number">1</span>    离开了车位
<span class="token number">2</span>    离开了车位
<span class="token number">3</span>    离开了车位
<span class="token number">5</span>    抢到了车位
<span class="token number">4</span>    抢到了车位
<span class="token number">6</span>    抢到了车位
<span class="token number">6</span>    离开了车位
<span class="token number">4</span>    离开了车位
<span class="token number">5</span>    离开了车位
<span class="token number">7</span>    抢到了车位
</code></pre>
<h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><ul>
<li><p>CountDownLatch 是一个线程等其他线程都执行完之后，用countDown()方法发出通知后，唤醒被 await() 的线      程，被唤醒的线程才可以继续执行</p>
</li>
<li><p>CyclicBarrier是所有线程都等待，直到所有线程都准备好后执行await()方法，当线程全部就绪之后，所有线程一起被唤醒。</p>
</li>
<li><p>CountDownLatch 的计数器只能使用一次，而CyclicBarrier可以使用reset()重置，所有CyclicBarrier可以处理更复杂的业务。</p>
</li>
</ul>
<h2 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h2><p>synchronized关键字是用来控制多线程环境下，控制 synchronized 代码段不被多个线程同时执行。可以加在方法上和代码块上</p>
<h4 id="锁升级的原理"><a href="#锁升级的原理" class="headerlink" title="锁升级的原理"></a>锁升级的原理</h4><p>​    synchronized锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候threadid 为空，jvm让其持有偏向锁，并将threadid 设置为其线程id，再次进入的时候会先判断 threadid  是否与其线程id一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized. 锁的升级。</p>
<p>​    synchronized关键字就像是汽车的<strong>自动档，</strong>现在详细讲这个过程。一脚油门踩下去，synchronized会从<strong>无锁</strong>升级为<strong>偏向锁</strong>，再升级为<strong>轻量级锁</strong>，最后升级为<strong>重量级锁</strong>，就像自动换挡一样。那么自旋锁在哪里呢？这里的轻量级锁就是一种<strong>自旋锁</strong>。</p>
<p>​    初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p>
<p>【对象头中包含 ：哈希码、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等内容】</p>
<p>​    如果一个线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活。<strong>如果线程A仍然存活，</strong>将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是<strong>如果判断结果是线程A不存在了</strong>，则线程B持有此偏向锁，锁不升级。</p>
<p>​    一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p>
<p>​    在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，CAS是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p>
<p>​    长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p>
<p>​    显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p>
<p>​    一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p>
<h4 id="synchronized-代码块底层的实现原理"><a href="#synchronized-代码块底层的实现原理" class="headerlink" title="synchronized 代码块底层的实现原理"></a>synchronized 代码块底层的实现原理</h4><p>​    同步代码块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p>
<h4 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a>synchronized方法底层原理</h4><p>​    方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</p>
<p>【补充：管程(Monitor)又叫监视器，是一种同步机制，保证同一个时间，只有一个线程访问被保护的数据，jvm的同步是基于进入和退出过程的，而进入和退出是通过管程对象进行实现的，每个Java对象都有一个管程对象，管程对象是会跟着java对象一起创建和销毁】</p>
<p>【补充：用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<p>​                内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡】</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>​     CAS的全称为Compare-And-Swap，它<strong>是一条CPU并发原语</strong>。<br>​    它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p>
<p>​    CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且<strong>原语的执行必须是连续的，不允许被中断</strong>，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p>
<h2 id="CAS导致的问题"><a href="#CAS导致的问题" class="headerlink" title="CAS导致的问题"></a>CAS导致的问题</h2><ul>
<li>循环时间长开销很大：如果一直没有替换的话就会一直在循环</li>
<li>只能保证一个共享变量的原子操作</li>
<li>引出来ABA问题</li>
</ul>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>​    比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B, 然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A,然后线程one操作成功。</p>
<p>可以通过JUC原子包下的 AtomicStampedReference类，添加一个版本号，每次修改都让版本号+1</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是jvm提供的轻量级的同步机制，有三个特性</p>
<ul>
<li>保证可见性：一个线程修改变量值之后，其他线程可以立即看到被修改后的值</li>
<li>不保证原子性 ：结合CAS可以解决这个问题</li>
<li>禁止指令重排：避免多线程环境下程序出现乱序执行的现象</li>
</ul>
<p>用 volatile 修饰 long  和 double时，读写都是原子操作，如果不用volatile修饰的话，在操作的时候分为两步，每一步都对32位操作</p>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>​    多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是，如果有一个线程想去写共享资源类，就不应该再有其他线程可以对该资源进行读写，所以就有了ReadWriteLock接口，具体的实现类是ReentrantReadWriteLock类，里面有两个静态内部类 ReadLock 和 WriteLock，实现了读写的分离，写锁是互斥的，读锁是共享的<br>​     读-读共存<br>​     读-写不能共存<br>​     写-写不能共存</p>
<h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><p>大厂面试题第三季看完在来补充</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>​    FutureTask是Future的实现类，是一个异步运算任务，FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务结果进行等待获取get()、判断是否完成 isDone()。</p>
<pre><code>1.在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，
 就可以通过Future对象获得后台作业的计算结果或者执行状态。
2.一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。
3.仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。
4.get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务直到完成状态，然后会返回结果或者抛出异常。
5.只计算一次get方法放到最后
</code></pre>
<h2 id="synchronized-和-Lock的区别"><a href="#synchronized-和-Lock的区别" class="headerlink" title="synchronized 和 Lock的区别"></a>synchronized 和 Lock的区别</h2><ul>
<li><p>设计层面的不同</p>
<ul>
<li><p>synchronized 是关键字，属于JVM层面的，字节码文件中有两处关键代码</p>
<ul>
<li>monitorenter：进锁</li>
</ul>
<p>​        底层是通过monitor对象来完成的，其实wait/notift方法也是依赖于monitor对象，只有在同步代码块或方法中才能调用wait/notift方法</p>
<ul>
<li>monitorexit：出锁，有两个，一个是正常退出，一个是出现异常之后退出</li>
</ul>
</li>
<li><p>lock是接口，是api层面的锁</p>
</li>
</ul>
</li>
<li><p>使用上的不同：</p>
<ul>
<li>synchronized 不需要用户去手动释放锁，当 synchronized  代码执行完后系统会自动让线程释放对锁的占用</li>
<li>ReentrantLock：需要手动去加锁和释放锁，如果不释放就有可能出现死锁</li>
</ul>
</li>
<li><p>是否可中断</p>
<ul>
<li>synchronized 不可中断，除非抛出异常或者正常运行完成</li>
<li>Lock 可中断<ul>
<li>设置 lock.tryLock(Long timeout, TimeUnit unit)</li>
<li>lock.lockInterruptibly()允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException</li>
</ul>
</li>
</ul>
</li>
<li><p>加锁是否公平</p>
<ul>
<li>synchronized  是非公平锁</li>
<li>ReentrantLock 两个都可以，用构造器的参数 false/true 就可以设置 非公平/公平锁，默认是非公平</li>
</ul>
</li>
<li><p>是否可以精准唤醒某个线程</p>
<ul>
<li>ReentrantLock 可以用 newCondition() 来创建一个Condition类，通过类中的await() 和 single() 方法可实现精准唤醒</li>
<li>synchronized不能，它只能随机唤醒一个或者全部唤醒</li>
</ul>
</li>
</ul>
<h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h2><p>联系就是 volatile 是轻量级锁，synchronized 是重量级锁</p>
<p>区别 </p>
<ul>
<li>volatile 是变量修饰符，synchronized可以修饰方法，代码块</li>
<li>volatile 只能实现变量的可见性，不能保证原子性，synchronized都可以实现</li>
<li>volatile  修饰的变量不会被编译器优化，synchronized可以被编译器优化</li>
<li>volatile性能比 synchronized要好，但是功能不如synchronized，所以一般还是用 synchronized的</li>
</ul>
<h2 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h2><p>乐观锁</p>
<p>​    对于并发间操作产生的线程安全问题持乐观状态，认为竞争不会发生，因此不需要持有锁，用CAS来实现乐观锁的修改操作</p>
<p>悲观锁</p>
<p>​    对于并发间操作产生的线程安全问题持悲观状态，认为竞争总会发生，因此每次对资源的操作都会持有一个独占锁</p>
<h2 id="sleep和wait有什么区别"><a href="#sleep和wait有什么区别" class="headerlink" title="sleep和wait有什么区别"></a>sleep和wait有什么区别</h2><p>sleep 方法和wait方法都可以用来放弃CPU一定的时间。</p>
<p>不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>
<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>​    ThreadLocal类是用来解决多线程的数据安全问题的，</p>
<p>底层原理：</p>
<p>​    每个ThreadLocal维护一个 ThreadLocalMap，这个Map的key是当前线程，value才是真正要存储的值。并且一个线程只能存储一个数据，要关联多个数据则需要多个ThreadLocal对象，由ThreadLocal负责向map中get和set线程的变量值，可以在同一线程的不同组件之间传递公共变量。</p>
<table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>ThreadLocal</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>同步机制采用’以时间换空间’的方式, 只提供了一份变量,让不同的线程排队访问</td>
<td>ThreadLocal采用’以空间换时间’的方式, 为每一个线程都提供了一份变量的副本,从而实现同时访问而相不干扰</td>
</tr>
<tr>
<td>侧重点</td>
<td>多个线程之间访问资源的同步</td>
<td>多线程中让每个线程之间的数据相互隔离</td>
</tr>
</tbody></table>
<p>​        </p>
<h2 id="为什么wait-和notify-方法要在同步代码块中被调用"><a href="#为什么wait-和notify-方法要在同步代码块中被调用" class="headerlink" title="为什么wait()和notify()方法要在同步代码块中被调用"></a>为什么wait()和notify()方法要在同步代码块中被调用</h2><p>​    当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用</p>
<h2 id="为什么wait-和notify-方法要声明在Object类里"><a href="#为什么wait-和notify-方法要声明在Object类里" class="headerlink" title="为什么wait()和notify()方法要声明在Object类里"></a>为什么wait()和notify()方法要声明在Object类里</h2><p>​    简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。</p>
<p>​    专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。</p>
<p>​    也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。</p>
<h2 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h2><p>​    Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程， 使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU.</p>
<h2 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h2><p>线程的调度器选择优先级高的线程运行，如果发生以下情况，就会终止线程的运行：</p>
<ul>
<li><p>线程内调用yield()方法让出了CPU的占用权</p>
</li>
<li><p>线程内调用sleep()方法</p>
</li>
<li><p>线程由于IO操作收到阻塞</p>
</li>
<li><p>另一个优先级更高的线程出现</p>
</li>
<li><p>线程的时间片用完了</p>
</li>
</ul>
<h2 id="线程调度器和时间片"><a href="#线程调度器和时间片" class="headerlink" title="线程调度器和时间片"></a>线程调度器和时间片</h2><p>​    线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间，一旦创建一个线程并启动它，它的执行便依赖于线程调度器的实现</p>
<p>​    时间片是指将可用的CPU时间分配给可用的Runnable线程的过程，分配CPU时间可以基于线程优先级或者线程等待的时间</p>
<p>​    最好不要让程序依赖于优先级，防止线程饥饿</p>
<h2 id="Linux环境下如何查找哪个线程使用CPU最长"><a href="#Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="Linux环境下如何查找哪个线程使用CPU最长"></a>Linux环境下如何查找哪个线程使用CPU最长</h2><p>第一步：获取项目的PID，通过命令  ps -ef | grep 项目名</p>
<p>第二部： top  -p pid</p>
<h2 id="死锁产生的原因和怎么避免"><a href="#死锁产生的原因和怎么避免" class="headerlink" title="死锁产生的原因和怎么避免"></a>死锁产生的原因和怎么避免</h2><p>死锁产生的原因是：不同的线程分别占用对方需要的同步资源不放，都在等待对方先放弃</p>
<p>形成死锁的必要条件</p>
<ul>
<li>互斥条件</li>
<li>占有且等待条件</li>
<li>不可抢占条件</li>
<li>循环等待条件</li>
</ul>
<p>避免：</p>
<ul>
<li>专门的算法，比如银行家算法</li>
<li>尽量避免嵌套同步</li>
<li>或者使用 tryLock(timeout) 来替代 lock()</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表示获得了锁</span>
        <span class="token comment" spellcheck="true">//执行逻辑代码</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//没有获取锁，就执行下面的代码</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>【补充：活锁：任务或者执行者没有被阻塞，但是由于某些条件不满足，导致一直重复尝试】</p>
<h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><p>​    线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>
<p>举个例子，假设Thread2中new了Thread1， main函数中new了Thread2，那么:</p>
<ul>
<li>Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</li>
<li>Thread1 的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li>
</ul>
<h2 id="线程的run-和-start-有什么区别"><a href="#线程的run-和-start-有什么区别" class="headerlink" title="线程的run() 和 start() 有什么区别"></a>线程的run() 和 start() 有什么区别</h2><p>​    每个线程都是通过某个特定Thread()对象所对应的方法run()来完成其操作的，方法体称为线程体，通过Thread类的start()方法来启动一个线程</p>
<p>​    start()方法用于启动线程，run()方法用于执行线程的运行时代码。run()可以重复调用，而start()只能调用一次</p>
<p>​    start()方法来启动一个线程，实现了真正的多线程运行，调用start()无需等待run()代码执行完毕，此时线程是处于就绪状态，等待CPU调度。</p>
<h2 id="为什么不能直接调用run-方法"><a href="#为什么不能直接调用run-方法" class="headerlink" title="为什么不能直接调用run()方法"></a>为什么不能直接调用run()方法</h2><p>​    new 一个 Thread就进入了创建状态，调用 start()方法进入了就绪状态，当分配到时间片就可以执行线程里的run()了</p>
<p>而直接调用run()，会把run()当成一个main线程下的普通方法去执行。</p>
<p>​    </p>
<h2 id="为什么Thread类的sleep-和yield-方法是静态的"><a href="#为什么Thread类的sleep-和yield-方法是静态的" class="headerlink" title="为什么Thread类的sleep()和yield ()方法是静态的?"></a>为什么Thread类的sleep()和yield ()方法是静态的?</h2><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的</p>
<h2 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="headerlink" title="如何停止一个正在运行的线程"></a>如何停止一个正在运行的线程</h2><ul>
<li>退出标志位</li>
<li>使用stop方法</li>
<li>使用interrupt方法中断线程</li>
</ul>
<h2 id="Java中interrupt、interrupted-和isInterrupted-方法的区别"><a href="#Java中interrupt、interrupted-和isInterrupted-方法的区别" class="headerlink" title="Java中interrupt、interrupted 和isInterrupted 方法的区别?"></a>Java中interrupt、interrupted 和isInterrupted 方法的区别?</h2><p>interrupt()：给线程设置一个中断标志。（注意，这里不同于stop()方法，并不是直接中断）。如果线程正在处于阻塞状态，那么此线程将抛出一个 InterruptedException异常中断线程。</p>
<p>interrupted ()：查看当前中断信号是true还是false并且清除中断信号。</p>
<p>isInterrupted ()：可以返回当前中断信号是true还是false，与interrupt最大的差别是不会清除中断信号</p>
<h2 id="什么是线程同步和线程互斥，有哪几种实现方式"><a href="#什么是线程同步和线程互斥，有哪几种实现方式" class="headerlink" title="什么是线程同步和线程互斥，有哪几种实现方式?"></a>什么是线程同步和线程互斥，有哪几种实现方式?</h2><p>线程同步：在没有完成相关操作之前，不允许其他线程打断它，否则就会破坏数据的完整性，必然会得到错误的处理结果</p>
<p>线程互斥：有若干个线程都要去使用某一些共享资源，任何时候最多只允许一个线程去使用</p>
<p>实现同步的方法：</p>
<ul>
<li>wait()/notify()/notifyAll()</li>
<li>await()/signal()/signalAll()</li>
</ul>
<p>实现互斥的方法：</p>
<ul>
<li>加synchronized</li>
<li>加Lock</li>
</ul>
<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>​    线程安全是指某个方法在多线程环境中被调用时，能够正确的处理多个线程之间的共享变量，使程序可以正确完成，保证线程的安全运行</p>
<ul>
<li>使用原子类  JUC下的atomic包</li>
<li>使用synchronized</li>
<li>使用 Lock</li>
</ul>
<p>线程数过多会造成线程的生命周期开销非常高、消耗过多的CPU</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>​    每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现,这个实现是和操作系统相关的。自己是可以定义线程的优先级的，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10),1代表最低优先级，10代表最高优先级，默认是5。一般不要设置，可能会出现线程饥饿。</p>
<p>​    通过setPriority()方法设置</p>
<h2 id="java中获取一份线程dump文件"><a href="#java中获取一份线程dump文件" class="headerlink" title="java中获取一份线程dump文件"></a>java中获取一份线程dump文件</h2><p>dump文件是进程的内存镜像，可以把程序的执行状态通过调试器保存到dump文件中</p>
<p>在Linux中 通过 kill -3 PID 来获取</p>
<ul>
<li>如果项目通过Tomcat进行发布（普通的web项目），则对应的堆栈信息会打印在catalina.out文件中。</li>
<li>如果项目是基于SpringBoot并且使用nohup java -jar xxx.jar &amp; 命令运行，则java堆栈信息会在jar包所在的nohup.out文件中。</li>
</ul>
<h2 id="final不可变对象对并发好处"><a href="#final不可变对象对并发好处" class="headerlink" title="final不可变对象对并发好处"></a>final不可变对象对并发好处</h2><p> 不可变对象保证了内存的可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率</p>
<h2 id="java中导致饥饿的原因"><a href="#java中导致饥饿的原因" class="headerlink" title="java中导致饥饿的原因"></a>java中导致饥饿的原因</h2><ul>
<li>高优先级线程吞噬所有低优先级线程的CPU时间</li>
<li>一线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
</ul>
<h2 id="Executor-和-Executors的区别"><a href="#Executor-和-Executors的区别" class="headerlink" title="Executor 和 Executors的区别"></a>Executor 和 Executors的区别</h2><p>Executors 工具类可以按照不同的需求创建不同的线程池(ThreadPoolExecutor)</p>
<p>Executor 接口对象能执行线程任务</p>
<p>ExecutorService接口继承了 Executor 接口，提供了更多的方法用于获取任务执行的状态，并且可以获取任务的返回值</p>
<h2 id="线程池七大参数"><a href="#线程池七大参数" class="headerlink" title="线程池七大参数"></a>线程池七大参数</h2><ul>
<li><p>corePoolSize</p>
<ul>
<li>线程池中常驻核心线程数</li>
</ul>
</li>
<li><p>maximumPoolSize</p>
<ul>
<li>线程池中能够同时容纳的最大线程数，此值必须大于等于1</li>
</ul>
</li>
<li><p>keepAliveTime</p>
<ul>
<li>多余空闲线程的存活时间，当前池中线程数超过 corePoolSize时，当空闲时间达到 keepAliveTime 时，多余线程会被销毁直到只剩下 corePoolSize 个线程为止</li>
</ul>
</li>
<li><p>TimeUnit</p>
<ul>
<li>keepAliveTime 的单位</li>
</ul>
</li>
<li><p>workQueue </p>
<ul>
<li>任务队列，被提交但尚未被执行的任务</li>
</ul>
</li>
<li><p>ThreadFactory</p>
<ul>
<li>表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认即可</li>
</ul>
</li>
<li><p>handler</p>
<ul>
<li>拒绝策略，表示当队列满了，并且工作线程大于等于 线程池的最大线程数时如何来拒绝请求执行的 runnable 的策略</li>
<li>四种拒接策略<ul>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>
<li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入到队列中尝试再次提交当前任务</li>
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许丢失，这是最好的一种策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四种创建线程池的区别和特点"><a href="#四种创建线程池的区别和特点" class="headerlink" title="四种创建线程池的区别和特点"></a>四种创建线程池的区别和特点</h2><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>特点：</p>
<p>newCachedThreadPool创建一个可缓存线程池，灵活扩容和收缩</p>
<p>缺点：</p>
<p>容易造成内存溢出，线程最大值为 Integer.MAX_VALUE</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>特点：</p>
<p>​    创建一个定长线程池，可控制最大并发数，超过的线程会在队列中等待</p>
<p>缺点：</p>
<p>​    阻塞队列是无界的，容易内存溢出</p>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>特点；</p>
<p>​    创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行</p>
<p>缺点：</p>
<p>​    由于所有任务都是由同一个线程来调度，因此所有任务都是串行的，同一时间只有一个任务在执行，前一个任务的延迟或者异常都会影响到之后的任务</p>
<p>​    最大线程数是 Integer.MAX_VALUE，容易造成内存溢出</p>
<h3 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h3><p>特点：</p>
<p>​    创建一个单线程的线程池，只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，必须保证所有任务按指定顺序执行，比如按FIFO或者优先级等。</p>
<p>缺点：</p>
<p>​    缺点就是因为是单线程，并发能力不足，而且阻塞队列是 Integer.MAX_VALUE，容易造成内存溢出</p>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul>
<li>RUNNABLE：正常状态，接收新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接收新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接收新的任务提交，不在处理等待队列中的任务，中断正在执行的线程</li>
<li>TIDYING：所有任务都销毁了，workCount为0，线程池的状态在转化为TIDYING状态时，会执行terminated()方法</li>
<li>TERMINATED：terminated()方法结束后就会进入此状态</li>
</ul>
<h2 id="线程池中-submit-和-execut-方法有什么区别"><a href="#线程池中-submit-和-execut-方法有什么区别" class="headerlink" title="线程池中 submit() 和 execut() 方法有什么区别"></a>线程池中 submit() 和 execut() 方法有什么区别</h2><p>相同点：</p>
<p>​    相同点就是都可以开启线程执行池中的任务</p>
<p>不同点</p>
<ul>
<li>execut() 只能执行Runnable类型的任务。submit()可以执行Runnable和Callable类型的任务</li>
<li>submit() 方法可以返回持有计算结果的 Future对象</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><ul>
<li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ul>
<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</li>
<li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程从队列中取出任务运行,并把这个任务放入队列中</li>
<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li>
</ul>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断： 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</li>
<li>线程池的所有任务完成后，它最终会收缩到corePoolSize的大小</li>
</ul>
<h2 id="如何分配线程池的大小"><a href="#如何分配线程池的大小" class="headerlink" title="如何分配线程池的大小"></a>如何分配线程池的大小</h2><p>要合理的分配线程池的大小，要根据实际情况来定。简单的来说的话就是根据CPU密集和 IO密集来分配</p>
<h3 id="CPU密集"><a href="#CPU密集" class="headerlink" title="CPU密集"></a>CPU密集</h3><p>​    CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。</p>
<p>​    配置最大线程数为 CPU + 1个线程</p>
<h3 id="IO密集"><a href="#IO密集" class="headerlink" title="IO密集"></a>IO密集</h3><p>​    IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力在等待上。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上,这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>​    配置最大线程数为 2 * CPU 个线程</p>
<h2 id="SynchronizedMap和ConcurrentHashMap-有什么区别"><a href="#SynchronizedMap和ConcurrentHashMap-有什么区别" class="headerlink" title="SynchronizedMap和ConcurrentHashMap 有什么区别"></a>SynchronizedMap和ConcurrentHashMap 有什么区别</h2><ul>
<li>SynchronizedMap一次锁住一整张表来保证线程安全，所以每次只能有一个线程来访问map</li>
<li>ConcurrentHashMap  使用分段锁来保证多线程下的性能，一次锁住一个桶，ConcurrentHashMap 默认将hash表分为16个桶，意味着同一时间可以有16和线程对数据进行操作，并发性提升是显而易见的</li>
<li>ConcurrentHashMap 的迭代器创建之后，就会按照hash表结构遍历每个元素，但在遍历过程中，内部元素可能发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</li>
</ul>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>写时复制<br>    CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后新的容器Object[] newElements里面添加一个元素，添加完元素之后，再将原容器的引用指向新的容器setArray(newElement)；</p>
<p>​    这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
   lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
      Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
      <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>好处就是当多个迭代器同时遍历和修改这个列表时，不会抛出  ConcurrentModificationException。</p>
<p>缺点：</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，内存不足</li>
<li>虽然能做到最终一致性，但无法满足实时性</li>
</ul>
<p>CopyOnWriteArrayList也<strong>不一定</strong>是线程安全的，理由如下：</p>
<p>​    用一个线程向容器中添加元素，一个线程来读取元素，而读取的操作往往更加频繁。写操作加锁保证了线程安全，读写分离保证了读操作的效率，但是如果这时候有第三个线程进行删除元素操作，读线程去读取容器中最后一个元素，读之前的时候容器大小为i，当去读的时候删除线程突然删除了一个元素，这个时候容器大小变为了i-1，读线程仍然去读取第i个元素，这时候就会发生数组越界。</p>
<h2 id="并发队列包括非阻塞队列和阻塞队列"><a href="#并发队列包括非阻塞队列和阻塞队列" class="headerlink" title="并发队列包括非阻塞队列和阻塞队列"></a>并发队列包括非阻塞队列和阻塞队列</h2><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>非阻塞队列就是队列没有元素是报异常或返回null，不会被阻塞</p>
<ul>
<li>PriorityQueue ： </li>
</ul>
<p>​    一个基 于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator 进行排序,具体取决于所使用的构造方法。该队列不允许使用nulk 元素也不允许插入不可比较的对象</p>
<ul>
<li>ConcurrentLinkedQueue :</li>
</ul>
<p>​    是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能。ConcurrentlinkedQueue 的性<br>能要好于BlockingQueue接口，它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。该队列不允许null元素。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ol>
<li><p>当队列是空的,从队列中获取元素的操作将会被阻塞</p>
</li>
<li><p>当队列是满的,从队列中添加元素的操作将会被阻塞</p>
</li>
<li><p>试图从空的队列中获取元素的线程将会被阻塞,直到其他线程往空的队列插入新的元素</p>
</li>
<li><p>试图向已满的队列中添加新元素的线程将会被阻塞,直到其他线程从队列中移除一个或多个元素或者完全清空,使队列变得空闲起来并后续新增</p>
</li>
</ol>
<ul>
<li><strong>ArrayBlockingQueue</strong><ul>
<li>由数组结构组成的有界阻塞对列</li>
</ul>
</li>
<li><strong>LinkedBlockQueue</strong><ul>
<li>由链表结构组成的有界(默认是Integer.MAX_VALUE)阻塞对列</li>
</ul>
</li>
<li><strong>SynchronousQueue</strong><ul>
<li>不存储元素的阻塞队列，也即单个元素的队列</li>
</ul>
</li>
<li>DelayQueue<ul>
<li>使用优先级队列实现的延迟无界阻塞队列</li>
</ul>
</li>
<li>PriorityBlockingQueue<ul>
<li>支持优先级排序的无界阻塞队列</li>
</ul>
</li>
<li>LinkedTransferQueue<ul>
<li>由链表组成的无界阻塞队列</li>
</ul>
</li>
<li>LinkedBlockingQueue<ul>
<li>由链表组成的双向阻塞队列</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p>​    任何线程都可以设置为守护线程和用户线程,通过方法Thread,setDaemon(boolon); true则把该线程设置为守护线程,反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。</p>
<p>区别：</p>
<p>​    唯一的区别是判断虚拟机(JVM)何时离开, Daemon是为其他线程提供服务,如果全部的User Thread已经撤离，Daemon没有可服务的线程，JVM撤离。比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机.上仅剩的线程时，Java虚拟机会自动离开。</p>
<p>​    <strong>守护进程在不执行finally子句的情况下就会终止其run()方法</strong></p>
<h2 id="什么是线程组，为什么在Java中不推荐使用"><a href="#什么是线程组，为什么在Java中不推荐使用" class="headerlink" title="什么是线程组，为什么在Java中不推荐使用?"></a>什么是线程组，为什么在Java中不推荐使用?</h2><p>​    线程组和线程池是两个不同的概念,他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p>
<h2 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h2><p>holdsLock()方法用于检测一个线程是否持有锁</p>
<h2 id="volatile-变量和atomic变量有什么不同"><a href="#volatile-变量和atomic变量有什么不同" class="headerlink" title="volatile 变量和atomic变量有什么不同"></a>volatile 变量和atomic变量有什么不同</h2><p>​    Volatile变量可以确保可见性和有序性，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用volatile修饰count变量，那么count++ 操作就不是原子性的。</p>
<p>​    而AtomicInteger类提供的atomic方法可以让这种操作具有原子性，如getAndIncrement0方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h2 id="什么是Java-Timer类-如何创建一个有特定时间间隔的任务"><a href="#什么是Java-Timer类-如何创建一个有特定时间间隔的任务" class="headerlink" title="什么是Java Timer类?如何创建一个有特定时间间隔的任务?"></a>什么是Java Timer类?如何创建一个有特定时间间隔的任务?</h2><p>​    java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p>
<h2 id="什么是阻塞式方法"><a href="#什么是阻塞式方法" class="headerlink" title="什么是阻塞式方法"></a>什么是阻塞式方法</h2><p>​    阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在<br>任务完成前就返回。</p>
<h2 id="线程间的数据交换"><a href="#线程间的数据交换" class="headerlink" title="线程间的数据交换"></a>线程间的数据交换</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Exchanger<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangerDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        Exchanger<span class="token operator">&lt;</span>String<span class="token operator">></span> exchanger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"等待小王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                String money <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"快递"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"得到了"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"快递小哥"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"等待快递小哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    String delivery <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"运费"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"得到了"</span> <span class="token operator">+</span> delivery<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//运行结果</span>
快递小哥等待小王
小王等待快递小哥
快递小哥得到了运费
小王得到了快递
</code></pre>
<p>​    java.util.concurrent包中的Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换</p>
<h2 id="在监视器内部是如何做线程同步的"><a href="#在监视器内部是如何做线程同步的" class="headerlink" title="在监视器内部是如何做线程同步的"></a>在监视器内部是如何做线程同步的</h2><p>​    在java虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一-个线程执行同步代码块。每一个监视器都和一对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<p>​    一旦或者代码块被synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。</p>
<p> 提供了隐式监视器synchronized 和 显示监视器 Lock</p>
<h2 id="一个线程运行时发生异常会怎么样"><a href="#一个线程运行时发生异常会怎么样" class="headerlink" title="一个线程运行时发生异常会怎么样"></a>一个线程运行时发生异常会怎么样</h2><p>​    如果异常没有被捕获，该线程将会停止执行，Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内部接口，当一个未捕获异常将造成线程中断的时候，JVM会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p>
<h2 id="多线程常用方法"><a href="#多线程常用方法" class="headerlink" title="多线程常用方法"></a>多线程常用方法</h2><p>sleep()：强迫线程休眠N毫秒</p>
<p>isAlive()：判断一个线程是否存活</p>
<p>join()：让一个线程插队在另一个线程之前完成</p>
<p>activeCount()：程序中活跃的线程数</p>
<p>currentThread()：当前线程</p>
<p>isDeamon()：是否是守护线程</p>
<p>setDeamon()：设置用户线程为守护线程</p>
<p>setName()：为线程设置名字</p>
<p>wait()：强迫一个线程等待</p>
<p>notify()：通知一个线程继续运行</p>
<p>setPriority()：设置线程的优先级</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>JMM 是一种抽象的概念，并不真实存在，它描述的是一组规则，通过这组规则定义了程序中各个变量的访问方式</p>
<p>三大特性 </p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<p>JMM关于同步的规定:</p>
<ul>
<li>线程加锁前，必须读取主内存的最新值到自己的工作内存.</li>
<li>线程解锁前，必须把共享变量的值刷新回主内存.</li>
<li>加锁解锁是同一把锁</li>
</ul>
<p>​    由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过主内存来完成，</p>
<h2 id="重排序遵守的规则"><a href="#重排序遵守的规则" class="headerlink" title="重排序遵守的规则"></a>重排序遵守的规则</h2><ul>
<li>不管怎么排序，结果不能改变</li>
<li>不存在数据依赖，可以被编译器和处理器重排序</li>
<li>单线程不会有问题，但多线程重排序后会有问题</li>
</ul>
<h2 id="as-if-serial规则和happens-before规则的区别"><a href="#as-if-serial规则和happens-before规则的区别" class="headerlink" title="as-if-serial规则和happens-before规则的区别"></a>as-if-serial规则和happens-before规则的区别</h2><p>​     as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。<br>​    as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p>
<h2 id="解释一下双重检验锁方式实现单例模式"><a href="#解释一下双重检验锁方式实现单例模式" class="headerlink" title="解释一下双重检验锁方式实现单例模式"></a>解释一下双重检验锁方式实现单例模式</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonDemo instance <span class="token operator">=</span> null<span class="token punctuation">;</span>

   <span class="token keyword">private</span> <span class="token function">SingletonDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

   <span class="token keyword">public</span> SingletonDemo <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
         <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
               instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
         <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>​    双检锁实现是基于懒汉式的方式的，第一个if是用来提高性能的，内部的 synchronized 代码块才是真正的单例实现，而且它的这个属性必须加 volatile修饰，因为   instance = new SingletonDemo() 这句代码分三步执行：</p>
<ol>
<li>为 instance  分配空间</li>
<li>初始化  instance  </li>
<li>将 instance  指向分配的内存地址</li>
</ol>
<p>​    但是由于JVM具有指令重排的特性，执行顺序有可能变成1-&gt;3-&gt;2，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程T1执行了1和3，此时T2调用 getInstance()不为空，因此返回 instance，但此时 instance 还未被初始化</p>
<p>​    使用volatile禁止指令重排，保证在多线程环境下也能正常运行</p>
<h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h2><p>​    SpringCloud是一系列框架的集合，利用springboot的便利简化了分布式系统基础设施的开发，比如服务注册，配置中心，负载均衡，断路器，数据监控等，都可以用springboot做到一键启动和部署</p>
<p>优点：</p>
<ul>
<li>服务拆分粒度更细，有利于资源重复利用，有利于提高开发效率</li>
<li>服务之间采用Restful的轻量级通讯机制</li>
<li>可以更精准的制定优化服务方案，提高系统的可维护性</li>
</ul>
<p>缺点：</p>
<ul>
<li>微服务过多，治理成本高，不利于维护系统</li>
<li>分布式系统开发的成本高</li>
</ul>
<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>​    微服务是一种架构风格，它是把一个应用拆分围绕着业务功能拆分为一组小型服务，每个服务都可以独立的部署和升级，服务之间用 HTTP 或者 RPC 交互</p>
<p>优点：</p>
<ul>
<li>单一职责：每个服务仅负责自己业务领域的功能</li>
<li>自治：一个微服务就是一个独立的实体，可以部署、升级、服务与服务之间通过HTTP等进行通信，并且一个微服务实例可以被替换成另一种实现，而对其他的微服务不产生影响</li>
<li>逻辑清晰：微服务单一职责特性使微服务看起来逻辑清晰，易于维护</li>
<li>简化部署：单系统中修改一处需要部署整个系统，而微服务中修改一处可单独部署一个服务</li>
<li>技术异构：不同的服务之间，可以根据自己的业务特点选择不同的技术架构。比如数据库等</li>
</ul>
<p>缺点：</p>
<ul>
<li>复杂度高：服务调用要考虑被调用方故障、过载、消息丢失等各种异常情况，代码逻辑更加复杂。</li>
<li>状态监控：系统由多个独立运行的微服务构成，需要设计一个良好的监控系统对各个微服务的运行状态进行监控</li>
<li>通信延迟：微服务之间调用会有时间消耗，造成通信延迟</li>
</ul>
<h2 id="SpringCloud-和-SpringBoot的认识"><a href="#SpringCloud-和-SpringBoot的认识" class="headerlink" title="SpringCloud 和 SpringBoot的认识"></a>SpringCloud 和 SpringBoot的认识</h2><p>​    SpringBoot是 Spring的一套快速配置脚手架，可以基于 SpringBoot 快速开发单个微服务， SpringCloud 是一个基于 SpringBoot实现的云应用开发工具</p>
<p>​    SpringBoot 专注于快速、方便集成的单个微服务个体，SpringCloud关注全局的服务治理框架。</p>
<p>​    SpringCloud  很大一部分是基于SpringBoot 来实现的，没有SpringCloud  就没有 SpringBoot</p>
<h2 id="什么是服务熔断"><a href="#什么是服务熔断" class="headerlink" title="什么是服务熔断"></a>什么是服务熔断</h2><p>​    达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p>
<h2 id="什么是服务降级"><a href="#什么是服务降级" class="headerlink" title="什么是服务降级"></a>什么是服务降级</h2><p>​    consumer端如果发现某个provider出现异常情况，比如经常超时，数据错误，这是consumer端可以采用一定的策略降级provider的逻辑，例如返回固定的数据等。</p>
<p>​    provider 端：当provider发现流量激增的时候，为了保护稳定性，也可以考虑降级服务。</p>
<p>​    </p>
<h2 id="什么是服务隔离"><a href="#什么是服务隔离" class="headerlink" title="什么是服务隔离"></a>什么是服务隔离</h2><p>​    服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。</p>
<h2 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h2><ul>
<li>服务网关 Zuul、GateWay</li>
<li>服务注册发现：Eureka 、zookeeper</li>
<li>负载均衡服务调用：Ribbon</li>
<li>服务接口调用 OpenFeign</li>
<li>服务限流降级熔断 Hystrix、Sentinel</li>
<li>配置中心 Config</li>
<li>。。。</li>
</ul>
<h2 id="服务的注册与发现的原理"><a href="#服务的注册与发现的原理" class="headerlink" title="服务的注册与发现的原理"></a>服务的注册与发现的原理</h2><p>​    服务在发布时指定对应的服务名(服务名包括了IP. 地址和端口)，将服务注册到注册中心(Eureka或者Zookeeper)，这一过程是Spring Cloud自动实现的，只需要在main 方法添加@EnableDisscoveryClient 即可。</p>
<p>​    调用方法：传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略调用( Ribbon和Feign)对应的服务。</p>
<h2 id="Eureka和Zookeeper都可以提供服务的注册与发现功能，有什么区别"><a href="#Eureka和Zookeeper都可以提供服务的注册与发现功能，有什么区别" class="headerlink" title="Eureka和Zookeeper都可以提供服务的注册与发现功能，有什么区别"></a>Eureka和Zookeeper都可以提供服务的注册与发现功能，有什么区别</h2><h3 id="Zookeeper保证CP"><a href="#Zookeeper保证CP" class="headerlink" title="Zookeeper保证CP"></a>Zookeeper保证CP</h3><p>​    zk可以保证数据一致性和分区容错性，但不能保证可用性。</p>
<p>​    Zookeeper中，当master节点因为网络故障等其他原因与其他节点失去联系时，剩余节点会重新进行leader选举，由于选举时间太长且期间整个zk集群都是不可用的，虽然最终服务能够恢复，但漫长的选举时间导致的注册长期不可用是不能容忍的</p>
<h3 id="Eureka保证-AP"><a href="#Eureka保证-AP" class="headerlink" title="Eureka保证 AP"></a>Eureka保证 AP</h3><p>​    Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或者发现连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的</p>
<h2 id="Eureka服务注册与发现原理"><a href="#Eureka服务注册与发现原理" class="headerlink" title="Eureka服务注册与发现原理"></a>Eureka服务注册与发现原理</h2><p>Eureka包含两个组件：</p>
<ul>
<li><p>Eureka Server：提供服务注册服务<br>各个微服务节点通过配置启动后，会在EurekaServer中进行注册， 这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息,服务节点的信息可以在界面中直观看到。</p>
</li>
<li><p>EurekaClient：通过注册中心进行访问<br>是一个Java客户端，用于简化Eureka Server的交互,客户端同时也具备一个内置的、 使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除(默认90秒)</p>
</li>
</ul>
<p>原理</p>
<ol>
<li>每30s发送心跳检测重新进行租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中心移除.</li>
<li>注册信息和更新会被复制到其他Eureka节点，来自任何区域的客户端可以查找到注册中心信息，每30s发生一次复制来定位他们的服务，并进行远程调用。这也就是Eureka为什么不能保证一致性的原因</li>
<li>客户端还可以缓存一些服务实例信息，所以即使Eureka全挂掉，客户端也是可以定位到服务地址的。</li>
</ol>
<p>多个消费者调用同一接口，eruka 的分配方式：</p>
<ul>
<li>RoundRobinRule:轮询策略， 以轮询的方式选择服务器，这个是默认值。</li>
<li>RandomRule:随机选择，随机从服务器列表中选择一个进行访问;</li>
<li>BestAvailableRule:最大可用策略，先过滤出故障服务器后，选择一个当前并发请求数最小的</li>
</ul>
<p>Eureka自我保护：</p>
<p>​    Eureka在运行期间会统计心跳失败的比例，在15分钟内是否低于85%，如果出现了低于的情况，Eureka Server会将当前的实例注册信息保护起来，同时提示一个警告，一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务。Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点(高可用)。当网络稳定时，当前实例新的注册信息会被同步到其他节点中(最终一致性)。Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪。</p>
<h2 id="漏桶算法和令牌桶算法"><a href="#漏桶算法和令牌桶算法" class="headerlink" title="漏桶算法和令牌桶算法"></a>漏桶算法和令牌桶算法</h2><p>漏桶算法：</p>
<p>​    请求先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率</p>
<p>令牌桶算法</p>
<p>​    系统会以一个恒定的速度往桶里放入令牌，而如果请求需要处理，则需要先从桶里获取一个令牌，当桶里没有令牌时，拒绝服务，如果桶满了的话，直接丢弃请求</p>
<h2 id="SpringCloud-核心组件及其作用以及工作原理"><a href="#SpringCloud-核心组件及其作用以及工作原理" class="headerlink" title="SpringCloud 核心组件及其作用以及工作原理"></a>SpringCloud 核心组件及其作用以及工作原理</h2><h3 id="SpringCloud-由以下几个核心组件构成"><a href="#SpringCloud-由以下几个核心组件构成" class="headerlink" title="SpringCloud 由以下几个核心组件构成"></a>SpringCloud 由以下几个核心组件构成</h3><ul>
<li>Eureka：各个服务启动时，Eureka Client都会将服务注册到 Eureka Server，并且 Eureka Client还可以反过来从 Eureka Server拉取注册表，从而知道其他服务在哪里</li>
<li>Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</li>
<li>Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</li>
<li>Hystrix：请求是通过Hystrix的线程池发起的，不同的请求走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩问题</li>
<li>Zuul：前端对后端的调用，统一从Zuul网关进入，由Zuul网关转发请求给对方的服务</li>
</ul>
<h2 id="什么是Hystrix"><a href="#什么是Hystrix" class="headerlink" title="什么是Hystrix"></a>什么是Hystrix</h2><p>​    Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 服务熔断“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h2 id="为什么要使用服务熔断以及原理"><a href="#为什么要使用服务熔断以及原理" class="headerlink" title="为什么要使用服务熔断以及原理"></a>为什么要使用服务熔断以及原理</h2><p>​    当一个服务调用另一个服务，由于网络原因或者自身原因出现问题时，调用者就会等待被调者的响应，当更多的服务请求到这些资源时，导致更多的请求等待，这样就会发生服务雪崩，断路器就是解决这一问题的。</p>
<p><strong>原理：</strong></p>
<p>熔断器开关由关闭到打开的状态转换是通过当前服务健康状况和设定阈值比较决定的。</p>
<p>【服务的健康状况=请求失败数/请求总数】</p>
<ul>
<li>当熔断器开关关闭时，请求被允许通过熔断器，如果当前健康状况高于设定阈值，开关继续保持关闭，如果当前健康状况低于设定阈值，开关切换为打开状态</li>
<li>当熔断器开关打开时，请求被禁止通过</li>
<li>熔断器开关打开一段时间后，熔断器会自动进入半开状态，这是熔断器只允许一个请求通过，当该请求调用成功时，熔断器恢复到关闭状态，若该请求失败，熔断器继续保持打开状态，接下来的请求被禁止通过</li>
</ul>
<h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>服务雪崩效应是一种因服务提供者不可用导致服务调用者不可用，并将不可用逐渐放大的过程</p>
<p>原因：</p>
<ul>
<li>流量激增</li>
<li>硬件故障</li>
<li>线程同步等待：如果一个核心业务线程调用非核心线程，这个非核心线程交由第三方系统完成，当第三方系统本身出现问题，导致核心线程阻塞，一直处于等待状态，而进程间的调用是有超时限制的，最终这条线程将断掉，也可能引发雪崩；</li>
</ul>
<p>解决：</p>
<ul>
<li>针对流量激增，采用自动扩缩容以应对突发流量，或在负载均衡器上安装限流模块。</li>
<li>针对硬件故障，多机房容灾，跨机房路由，异地多活等。</li>
<li>针对同步等待，使用Hystrix做故障隔离，熔断器机制等可以解决依赖服务不可用的问题。</li>
</ul>
<h2 id="接口限流方法"><a href="#接口限流方法" class="headerlink" title="接口限流方法"></a>接口限流方法</h2><ul>
<li>限制瞬时并发数：如nginx的limit_conn模块</li>
<li>限制远程接口调用速率</li>
<li>限制MQ的消费速率</li>
</ul>
<h2 id="微服务之间是如何独立通讯的"><a href="#微服务之间是如何独立通讯的" class="headerlink" title="微服务之间是如何独立通讯的"></a>微服务之间是如何独立通讯的</h2><h3 id="REST-HTTP-协议"><a href="#REST-HTTP-协议" class="headerlink" title="REST HTTP 协议"></a>REST HTTP 协议</h3><p>REST 请求在微服务中是最为常用的一种通讯方式，它依赖于 HTTP\HTTPS 协议。</p>
<ul>
<li>每一个 URI 代表 1 种资源</li>
<li>客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作</li>
<li>客户端与服务端之间的交互在请求之间是无状态的,从客户端到服务端的每个请求都必须包含理解请求所必需的信息</li>
</ul>
<h3 id="RPC远程过程调用"><a href="#RPC远程过程调用" class="headerlink" title="RPC远程过程调用"></a>RPC远程过程调用</h3><p>​     RPC(Remote Procedure Call Protocol)——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<ul>
<li>客户端(Client)，服务的调用方。</li>
<li>客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端(Server)，真正的服务提供者。</li>
<li>服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。   </li>
</ul>
<h2 id="什么是-Feign以及优点"><a href="#什么是-Feign以及优点" class="headerlink" title="什么是 Feign以及优点"></a>什么是 Feign以及优点</h2><p>​    Feign是一个声明式WebService客户端，只需要几个注解和抽象方法就可以实现服务接口的调用</p>
<ul>
<li>feign采用了基于接口的注解</li>
<li>Feign整合了 Ribbon，具有负载均衡的能力</li>
<li>整合了Hystrix，具有熔断功能</li>
</ul>
<p>使用：</p>
<ul>
<li>导入依赖</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre>
<ul>
<li>在配置类上添加  @EnableFeignClients</li>
<li>指定一个接口，标明调用哪个服务的哪个方法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"CLOUD-PAYMENT-SERVICE"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PaymentFeignService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/payment/get/&amp;#123;id&amp;#125;"</span><span class="token punctuation">)</span>
    CommonResult <span class="token function">getPaymentById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="Ribbon本地负载的衡客户端与Nginx服务端负载均衡区别"><a href="#Ribbon本地负载的衡客户端与Nginx服务端负载均衡区别" class="headerlink" title="Ribbon本地负载的衡客户端与Nginx服务端负载均衡区别"></a>Ribbon本地负载的衡客户端与Nginx服务端负载均衡区别</h2><ul>
<li>Nginx是服务器负载均衡，客户端所有请求都会交给nginx,然后由nginx实现转发请求。即负载均衡是由服务端实现的。</li>
<li>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到 JVM 本地，从而在本地实现RPC远程服务调用技术。</li>
</ul>
<p>负载均衡的意义：</p>
<p>​    负载均衡目的在优化资源的使用，最小化响应时间，最大化吞吐量</p>
<h2 id="Ribbon和Feign调用服务的区别"><a href="#Ribbon和Feign调用服务的区别" class="headerlink" title="Ribbon和Feign调用服务的区别"></a>Ribbon和Feign调用服务的区别</h2><p>调用方式不同： Ribbon 需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐</p>
<p>而Feign则是在Ribbon的基础上进行了一次改进,采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</p>
<h2 id="什么是-Spring-Cloud-Bus"><a href="#什么是-Spring-Cloud-Bus" class="headerlink" title="什么是 Spring Cloud Bus"></a>什么是 Spring Cloud Bus</h2><p>​    在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。 基本原理ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p>
<h2 id="你所知道微服务的技术栈有哪些"><a href="#你所知道微服务的技术栈有哪些" class="headerlink" title="你所知道微服务的技术栈有哪些"></a>你所知道微服务的技术栈有哪些</h2><table>
<thead>
<tr>
<th>微服务条目</th>
<th>技术栈</th>
</tr>
</thead>
<tbody><tr>
<td>服务开发</td>
<td>Spring Boot、Spring、SpringMVC</td>
</tr>
<tr>
<td>服务配置与管理</td>
<td>阿里的Dlamond</td>
</tr>
<tr>
<td>服务注册与发现</td>
<td>Eureka、Consul、Zookeeper</td>
</tr>
<tr>
<td>服务调用</td>
<td>RestFul、RPC</td>
</tr>
<tr>
<td>服务熔断器</td>
<td>Hystrix</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Nginx、Ribbon</td>
</tr>
<tr>
<td>服务接口调用</td>
<td>Feign</td>
</tr>
<tr>
<td>消息队列</td>
<td>RabbitMQ、ActiveMQ</td>
</tr>
<tr>
<td>服务配置中心管理</td>
<td>SpringCloudConfig</td>
</tr>
<tr>
<td>服务路由</td>
<td>Zuul</td>
</tr>
<tr>
<td>服务部署</td>
<td>Docker</td>
</tr>
<tr>
<td>事件消息总线</td>
<td>SpringCloudBus</td>
</tr>
</tbody></table>
<h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>​     Spring CloudConfig为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。SpringCloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client 通过调用Config Server的接口来读取配置文件。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。 </p>
<p>​    Spring Cloud Config 配合 Spring Cloud Bus使用可以实现配置的动态刷新</p>
<h2 id="Spring-Cloud-Netfilx"><a href="#Spring-Cloud-Netfilx" class="headerlink" title="Spring Cloud Netfilx"></a>Spring Cloud Netfilx</h2><p>Spring Cloud Netfilx包括：</p>
<ul>
<li>Eureka：服务治理组件，包括服务端的注册中心和客户端的访问发现机制</li>
<li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略</li>
<li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了错误能力</li>
<li>Feign：基于Ribbon 和 Hystrix 的声明式服务调用组件；</li>
<li>Zuul：API网关组件，对请求提供路由及过滤功能</li>
</ul>
<h2 id="微服务的端到端测试意味着什么"><a href="#微服务的端到端测试意味着什么" class="headerlink" title="微服务的端到端测试意味着什么"></a>微服务的端到端测试意味着什么</h2><p>​    端到端测试验证工作流中的所有流程,以检查–切是否按预期工作。它还确保系统以统一的方式工作，从而满足业务需求。</p>
<h2 id="什么是凝聚力"><a href="#什么是凝聚力" class="headerlink" title="什么是凝聚力"></a>什么是凝聚力</h2><p>模块内部元素所属的程度被认为是凝聚力</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>  单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。 </p>
<p>  一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</p>
<p>分布式事务处理过程是 一个 ID+三个组件  的模型</p>
<ul>
<li><p>Transaction ID XID：全局唯一的事务ID</p>
</li>
<li><p>Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；</p>
</li>
<li><p>Transaction Manager (TM)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；</p>
</li>
<li><p>Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚</p>
</li>
</ul>
<p>处理过程：</p>
<p>​        TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；XID 在微服务调用链路的上下文中传播；RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；TM 向 TC 发起针对 XID 的全局提交或回滚决议；TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。  </p>
<h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h2><p>​    网关相当于一个网络服务架构的入口，所有网络请求都必须通过网关转发到具体的服务</p>
<p>​    作用就是统一管理微服务请求，权限控制，负载均衡、路由转发、监控</p>
<p>​    网关和过滤器有什么区别：</p>
<p>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言</p>
<h2 id="Zuul网关如何搭建集群"><a href="#Zuul网关如何搭建集群" class="headerlink" title="Zuul网关如何搭建集群"></a>Zuul网关如何搭建集群</h2><p>​    使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。</p>
<h2 id="HTTP原理"><a href="#HTTP原理" class="headerlink" title="HTTP原理"></a>HTTP原理</h2><p>​    HTTP(超文本传输协议)是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息，HTTP 遵循请求(Request)/应答(Response)模型。</p>
<p>特点：</p>
<ul>
<li>无连接</li>
<li>无状态</li>
<li>客户端/服务端模型</li>
<li>简单快速</li>
<li>灵活，可以传输任何类型的数据</li>
</ul>
<h2 id="Http协议的请求方式是什么"><a href="#Http协议的请求方式是什么" class="headerlink" title="Http协议的请求方式是什么"></a>Http协议的请求方式是什么</h2><p>​    Http是一个基于 TCP/IP通信协议来传递数据，包括文件、图像等，是一个客户端和服务器端请求和应答的标准，基本上用到的就是Get和Post</p>
<h2 id="Http-和-Https-有什么区别"><a href="#Http-和-Https-有什么区别" class="headerlink" title="Http 和 Https 有什么区别"></a>Http 和 Https 有什么区别</h2><ul>
<li>Https有ca证书，Http没有</li>
<li>Http是超文本传输协议，信息是明文传输，Https是具有安全性的ssl加密传输协议</li>
<li>Http默认80端口，Https默认443</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
</ul>
<h2 id="cookies机制和session机制的区别是什么"><a href="#cookies机制和session机制的区别是什么" class="headerlink" title="cookies机制和session机制的区别是什么"></a>cookies机制和session机制的区别是什么</h2><ul>
<li>cookies 数据保存在客户端，session 数据保存在服务端;</li>
<li>cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗; </li>
<li> session 安全一点，但是占用服务器资源。</li>
</ul>
<p>cookies和session可以解决Http无状态协议</p>
<h2 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h2><ul>
<li>get不安全，post安全</li>
<li>get传输数据有大小限制，post没有限制</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET产生一个TCP数据包，POST产生两个数据包，get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200，返回数据；而对于POST请求，浏览器先发送header，服务器响应100，浏览器在发送data，服务器响应200，返回数据</li>
</ul>
<h2 id="Http协议中的302状态"><a href="#Http协议中的302状态" class="headerlink" title="Http协议中的302状态"></a>Http协议中的302状态</h2><p>302表示重定向，服务器返回的头部信息中会包含一个Location字段，内容是重定向的url</p>
<h2 id="Http协议的组成"><a href="#Http协议的组成" class="headerlink" title="Http协议的组成"></a>Http协议的组成</h2><p>Http协议是由Http报文组成的，分为请求报文和响应报文组成</p>
<ul>
<li><p>请求报文</p>
<ul>
<li>请求行：包含请求方法，URL，Http版本信息</li>
<li>请求头： 客户端发送给服务器端的一些信息，用键值对表示。</li>
<li>请求体：请求体，只有post请求才会有请求体，get没有</li>
</ul>
</li>
<li><p>响应报文</p>
<ul>
<li>响应行：常用状态码</li>
<li>响应头：服务器端将信息以键值对的形式返回给客户端</li>
<li>响应体：是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染，显示在页面内容。</li>
</ul>
</li>
</ul>
<h2 id="什么是TCP-IP和UDP"><a href="#什么是TCP-IP和UDP" class="headerlink" title="什么是TCP/IP和UDP"></a>什么是TCP/IP和UDP</h2><p>​    TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说。通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达。</p>
<p>​    UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接，所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p>
<p>运行在TCP上的协议：</p>
<ul>
<li>HTTP</li>
<li>HTTPS</li>
<li>POP3</li>
</ul>
<p>运行在UDP上的协议：</p>
<ul>
<li>DHCP</li>
<li>NTP</li>
</ul>
<p>运行在TCP和UPD上的协议：</p>
<ul>
<li>DNS</li>
<li>ARP</li>
</ul>
<h2 id="TCP协议与UDP协议有什么区别"><a href="#TCP协议与UDP协议有什么区别" class="headerlink" title="TCP协议与UDP协议有什么区别"></a>TCP协议与UDP协议有什么区别</h2><p>1、<strong>TCP</strong>基于<strong>连接</strong>，而UDP基于<strong>无连接</strong>的； </p>
<p>2、对系统资源的要求：TCP<strong>多</strong>（TCP有20个字节信息包），UDP<strong>少</strong>（UDP信息包只有8个字节）；  </p>
<p>3、TCP是<strong>字节流模式</strong>，而UDP是<strong>数据报文模式</strong> ；</p>
<p>4、TCP保证数据正确性，<strong>安全可靠</strong>，并且保证<strong>数据顺序</strong>，而UDP可能<strong>丢包</strong>，而且UDP<strong>不保证数据顺序</strong>。</p>
<h2 id="常见的Http响应状态码"><a href="#常见的Http响应状态码" class="headerlink" title="常见的Http响应状态码"></a>常见的Http响应状态码</h2><p>200：请求被正常处理</p>
<p>204：请求被处理但没有资源可以返回</p>
<p>301：永久重定向</p>
<p>302：临时重定向</p>
<p>400：服务器无法识别请求报文</p>
<p>404：服务器无法找到对应的资源</p>
<p>500：服务器内部有错误</p>
<p>503：服务器正忙</p>
<h2 id="什么是网络编程"><a href="#什么是网络编程" class="headerlink" title="什么是网络编程"></a>什么是网络编程</h2><p>网络编程的本质是多台计算机之间的数据交换，基于请求/响应方式，客户端发送请求给服务端，服务端返回数据给客户端</p>
<p>主要考虑两个问题：</p>
<ul>
<li>如何准确的定位网络上一台或多台主机</li>
<li>找到主机后如何可靠高效的进行数据传输</li>
</ul>
<p>在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一确定网络上的一台主机</p>
<p>TCP层则提供面向应用的可靠(TCP)或非可靠(UDP)的数据传输机制.</p>
<h2 id="网络协议是什么"><a href="#网络协议是什么" class="headerlink" title="网络协议是什么"></a>网络协议是什么</h2><p>​    在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<h2 id="为什么要对网络协议分层"><a href="#为什么要对网络协议分层" class="headerlink" title="为什么要对网络协议分层"></a>为什么要对网络协议分层</h2><p>​    简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。易于实现和维护。促进标准化工作。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>​    OSI(开放式系统互联)定义了网络的七层架构</p>
<p>应用层、表述层、会话层、网络层、传输层、数据链路层、物理层</p>
<h2 id="TCP-IP四层协议"><a href="#TCP-IP四层协议" class="headerlink" title="TCP/IP四层协议"></a>TCP/IP四层协议</h2><p>应用层：应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务，比如HTTP、HTTPS</p>
<p>传输层：建立了主机 端到端的链接。TCP/UDP协议就是传输层的</p>
<p>网络层：通过IP寻址来建立两个节点之间的连接，使主机可以把分组发往任何网络，并使分组独立地传向目标</p>
<p>网络接口层：必须使用某种协议与网络相连</p>
<h2 id="什么是ARP协议"><a href="#什么是ARP协议" class="headerlink" title="什么是ARP协议"></a>什么是ARP协议</h2><p>​    ARP协议完成了IP地址与物理地址的映射。每一个主机都有一个ARP 高速缓存，里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包(在发送自己的ARP请求时，同<br>时会带上自己的IP 地址到硬件地址的映射) ，收到请求的主机检查自己的IP地址和目的主机的IR地址是否一致，如果一致，则先保存源主机的映射到自已的ARP缓存，然后给源主机发送一一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p>
<h2 id="从输入地址到获得页面的过程"><a href="#从输入地址到获得页面的过程" class="headerlink" title="从输入地址到获得页面的过程"></a>从输入地址到获得页面的过程</h2><ol>
<li>浏览器查询DNS，获取域名对应的IP地址，具体包括浏览器搜索自身的DNS缓存，搜索操作系统的DNS缓存，读取本地的Host文件等，返回解析结果给客户机</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求</li>
<li>服务器接收请求，将处理结果以及相应的视图返回给浏览器</li>
<li>浏览器解析渲染视图，若遇到js等静态文件的引用，还是向服务器请求这些资源</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终呈现一个完整的页面</li>
</ol>
<h2 id="三次握手的具体细节"><a href="#三次握手的具体细节" class="headerlink" title="三次握手的具体细节"></a>三次握手的具体细节</h2><p>第一次握手：Client 将 SYN 置为1，随机产生一个初始序列号seq(32位)发送给Server，进入SYN_SENT状态</p>
<p>第二次握手：Server收到Client的SYN = 1之后，知道客户端请求建立连接，将自己的SYN置为1，ACK置为1，ack number = seq+1发送给服务器，并随机产生一个自己的初始序列号ack number1发送给客户端，进入SYN_RCVD状态</p>
<p>第三次握手：客户端检查 ack number是否为序列号+1，ACK是否为1，检查正确后将自己的ACK置为1，产生一个ack number2 =  ask number1 + 1 发送给服务器，进入ESTABLISHED状态。服务器检查ACK为1和ack number2为ask number1 + 1之后，也进入ESTABLISHED状态，三次握手完成，连接建立</p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210916100458.png"></p>
<h2 id="可以采用两次握手吗"><a href="#可以采用两次握手吗" class="headerlink" title="可以采用两次握手吗"></a>可以采用两次握手吗</h2><p>​    不行，假设不采用三次握手，那么只要server发出确认，新的连接就建立了，由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，而server却以为新的运输连接已经建立了，就一直等待client发来的数据，这就白浪费资源了。</p>
<p>那可以采用四次握手吗</p>
<p>​    肯定可以：三次握手都可以保证连接成功了，但是四次会降低传输效率</p>
<h2 id="第三次握手中，如果客户端的ACK未送达服务器，会怎样"><a href="#第三次握手中，如果客户端的ACK未送达服务器，会怎样" class="headerlink" title="第三次握手中，如果客户端的ACK未送达服务器，会怎样"></a>第三次握手中，如果客户端的ACK未送达服务器，会怎样</h2><p>Server端：由于Server没有收到ACK确认，因此会每隔3秒重发之前的SYN+ACK (默认重发五次，之后自动关闭连接进入CLOSED状态)，Client 收到后会重新传，ACK给Server。</p>
<p>如果服务端没有进入CLOSED，服务端收到数据之后会读取ack  number 进入established状态</p>
<p>如果服务端进入了CLOSED，Client向服务器发送数据，服务器会以RST包应答</p>
<h2 id="如果已经建立了连接，但客户端出现了故障怎么办"><a href="#如果已经建立了连接，但客户端出现了故障怎么办" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办"></a>如果已经建立了连接，但客户端出现了故障怎么办</h2><p>​    服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>第一次挥手，Client 将FIN置为1，发送一个序列号seq1给Server，进入FIN_WAIT_1状态</p>
<p>第二次挥手，Server 收到FIN后，发送一个ACK=1，ack number= seq1 + 1，进入CLOSE_WAIT状态，此时服务端已经没有要发送的数据了，但仍然可以接收服务器发送的数据</p>
<p>第三次挥手，Server 将FIN置为1，发送一个序列号seq2和ack number= seq1 + 1给Client，进入LAST_ACK状态</p>
<p>第四次挥手，Client收到服务器的FIN后，进入TIME_WAIT状态，接着将ACK置为1，发送一个ack number = seq2 + 1给服务器，服务器收到后确认ack number 后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL(报文段最长寿命)时间后，也进入CLOSED状态，完成四次挥手</p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210916100437.png"></p>
<h2 id="为什么不能把服务器发送的ACK和FIN合并起来，变成3次挥手-CLOSE-WAIT状态意义是什么"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成3次挥手-CLOSE-WAIT状态意义是什么" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成3次挥手(CLOSE WAIT状态意义是什么)"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成3次挥手(CLOSE WAIT状态意义是什么)</h2><p>​    因为服务器收到客户端断开连接的请求时，服务器可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传。</p>
<h2 id="客户端TIME-WAIT状态的意义是什么"><a href="#客户端TIME-WAIT状态的意义是什么" class="headerlink" title="客户端TIME WAIT状态的意义是什么"></a>客户端TIME WAIT状态的意义是什么</h2><p>​    第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会给客户端重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p>
<p>​    MSL(Maximum Segment lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client 都没有再次收到FIN，那么Client 推断ACK已经，被成功接收，则结束TCP连接。</p>
<h2 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h2><p>​    网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为Socket，通常用来实现客户方和服务方的连接，Socket由一个IP地址和一个端口号唯一确定，java环境下，Socket主要还是基于TCP/IP协议的网络编程，    </p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>whw<span class="token punctuation">.</span>java1<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetAddress<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ServerSocket<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 实现TCP的网络编程
 * 例子1：客户端发送信息给服务端，服务端将数据显示在控制台上
 *
 * @author shkstart
 * @create 2019 下午 3:30
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TCPTest1</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//客户端</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        Socket socket <span class="token operator">=</span> null<span class="token punctuation">;</span>
        OutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//1.创建Socket对象，指明服务器端的ip和端口号</span>
            InetAddress inet <span class="token operator">=</span> InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>inet<span class="token punctuation">,</span><span class="token number">8899</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//2.获取一个输出流，用于输出数据</span>
            os <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//3.写出数据的操作</span>
            os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"你好，我是客户端mm"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//4.资源的关闭</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>os <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>socket <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//服务端</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

        ServerSocket ss <span class="token operator">=</span> null<span class="token punctuation">;</span>
        Socket socket <span class="token operator">=</span> null<span class="token punctuation">;</span>
        InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>
        ByteArrayOutputStream baos <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//1.创建服务器端的ServerSocket，指明自己的端口号</span>
            ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8899</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//2.调用accept()表示接收来自于客户端的socket</span>
            socket <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//3.得到输入流</span>
            is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//4.获取输入流中的数据</span>
            baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> len<span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>baos<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到了来自于："</span> <span class="token operator">+</span> socket<span class="token punctuation">.</span><span class="token function">getInetAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">finally</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>baos <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//5.关闭资源</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    baos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>is <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>socket <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ss <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    ss<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="Socket-和-Http的区别和应用场景"><a href="#Socket-和-Http的区别和应用场景" class="headerlink" title="Socket 和 Http的区别和应用场景"></a>Socket 和 Http的区别和应用场景</h2><p>Socket 连接就是所谓的长连接，理论上客户端和服务端一旦建立起连接就不会主动断掉</p>
<p>​    Socket 适合网络游戏，直播等在线交流</p>
<p>Http连接就是所谓的短连接，客户端向服务端发送一次请求，服务器响应后连接就会立即断开</p>
<p>​    Http适合互联网服务，网站等</p>
<h2 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h2><ul>
<li><p>浏览器将自己支持的一套加密规则发送给网站。</p>
</li>
<li><p>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>
</li>
<li><p>浏览器获得网站证书之后浏览器要做以下工作：</p>
<ul>
<li>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li>
<li> 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li>
<li>使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li>
</ul>
</li>
<li><p>网站接收浏览器发来的数据之后要做以下的操作：</p>
<ul>
<li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li>
<li>使用密码加密一段握手消息，发送给浏览器。</li>
</ul>
</li>
<li><p>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p>
<p> 非对称加密算法：RSA，DSA/DSS<br> 对称加密算法：AES，RC4，3DES<br> HASH算法：MD5，SHA1，SHA256</p>
</li>
</ul>
<h2 id="Http请求所经历的步骤"><a href="#Http请求所经历的步骤" class="headerlink" title="Http请求所经历的步骤"></a>Http请求所经历的步骤</h2><ul>
<li>建立TCP连接</li>
<li>Web浏览器向web服务器发送请求行</li>
<li>web浏览器发送请求头<ul>
<li>   浏览器发送其请求命令之后,还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</li>
</ul>
</li>
<li>web服务器应答<ul>
<li>客户机向服务器发出请求后，服务器会客户机回送应答，比如协议版本和状态码</li>
</ul>
</li>
<li>web服务器发送应答头<ul>
<li>  正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li>
</ul>
</li>
<li>web服务器向浏览器发送数据<ul>
<li>   Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据，也就是响应体。</li>
</ul>
</li>
<li>关闭 TCP 连接</li>
</ul>
<h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>​    对称密钥加密是指加密和解密使用同-一个密钥的方式，这种方式存在的最大问题，就是密钥发送问题，即如何安全地将密钥发给对方</p>
<p>​    非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有服务器知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，非常的慢。</p>
<h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>MQ就是消息队列，是软件和软件进行通信的中间产品</p>
<ul>
<li>异步处理：相比于传统串行、并行，提高了系统吞吐量</li>
<li>应用解耦：系统间提高消息通信，不用关心其他系统的处理</li>
<li>流量削峰：可以通过消息队列长度控制请求量；可以缓解短时间的高并发请求</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统可用性降低<ul>
<li>系统运行的好好的，消息队列挂了。</li>
</ul>
</li>
<li>系统复杂性提高<ul>
<li>加了消息队列，需要考虑很多方面的问题，比如一致性、如何保证消息不被重复消费，以及可靠传输等</li>
</ul>
</li>
<li>一致性问题<ul>
<li>A系统处理完后返回成功，系统就以为你这个请求成功了，但是要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了该怎么办</li>
</ul>
</li>
</ul>
<h2 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h2><p>RabbitMQ是实现了AMQP的消息中间件，RabbitMQ服务器是用erlang语言编写的</p>
<p>​    AMQP：高级消息队列协议，它是应用层协议的一个标准，基于此协议的客户端和消息中间件可传递消息，并不受产品、开发语言等条件的限制，RabbitMQ中的交换器，队列，绑定都是遵循AMQP协议中相应的概念</p>
<p>特点：</p>
<ul>
<li>有管理界面</li>
<li>高可用集群，因为是镜像集群</li>
<li>灵活的路由</li>
</ul>
<h2 id="AMQP三层协议"><a href="#AMQP三层协议" class="headerlink" title="AMQP三层协议"></a>AMQP三层协议</h2><ul>
<li>Module Layer：协议最高层，主要定义了一些客户端调用的命令，客户端可以用这写命令实现自己的业务逻辑</li>
<li>Session Layer：中间层，主要负责客户端命令发送给服务器，在将服务器端应答返回客户端，提供可靠同步机制和错误处理</li>
<li>TransportLayer：最底层，主要传输二进制数据流</li>
</ul>
<h2 id="RabbitMQ基本概念"><a href="#RabbitMQ基本概念" class="headerlink" title="RabbitMQ基本概念"></a>RabbitMQ基本概念</h2><p><strong>Broker</strong>：接收和分发消息的应用，Broker就相当于一个RabbitMQ服务节点</p>
<p><strong>Virtual host</strong>：当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建exchange／queue </p>
<p><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</p>
<p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP(高级消息队列协议) method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的</strong>，<strong>Connection极大减少了操作系统建立TCP connection的开销</strong> </p>
<p><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。</p>
<p>有以下三种交换机</p>
<ul>
<li>direct模式根据路由键把消息派发到一个指定队列。</li>
<li>fanout模式不管路由键，将消息派发给对应的绑定了交换器的所有消息队列。</li>
<li>topic模式是根据路由键的规则匹配，有选择性的进行广播。</li>
</ul>
<p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走，多个消费者可以订阅同一队列，这时队列中的消息会被平摊给多个消费者进行处理。queue里存放的数据时无数量限制的</p>
<p><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key(最大255字节)，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p>
<p><strong>RoutingKey</strong>：Routing Key就是路由规则，消息对应的队列。路由键来规定。</p>
<h2 id="RabbitMQ工作模式"><a href="#RabbitMQ工作模式" class="headerlink" title="RabbitMQ工作模式"></a>RabbitMQ工作模式</h2><h3 id="simple模式"><a href="#simple模式" class="headerlink" title="simple模式"></a>simple模式</h3><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210812221453.png"></p>
<ul>
<li>消息生产消息，将消息放入队列中</li>
<li>消费者监听消息队列，如果队列中有消息，就消费掉。消息被拿走后自动从队列中删除，也可以设置手动应答。</li>
</ul>
<h3 id="work工作模式"><a href="#work工作模式" class="headerlink" title="work工作模式"></a>work工作模式</h3><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210926115507.png"></p>
<p>消息生产者将消息放入队列中，消费者可以有多个，并且同时监听一个队列，多个消费者共同争抢一个消息。一个消息只能被消费一次</p>
<h3 id="发布订阅-1"><a href="#发布订阅-1" class="headerlink" title="发布订阅"></a>发布订阅</h3><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210926115953.png"></p>
<p>每个消费者监听自己的队列</p>
<p>生产者将消息发送给borker，由交换机将消息转发到绑定此交换机的每个队列。</p>
<h3 id="routing路由"><a href="#routing路由" class="headerlink" title="routing路由"></a>routing路由</h3><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210926120143.png"></p>
<p>消息生产者将消息发送给交换机，交换机按照路由判断，交换机根据路由的key，只能匹配上路由的key对应的消息队列</p>
<h3 id="topic主题模式"><a href="#topic主题模式" class="headerlink" title="topic主题模式"></a>topic主题模式</h3><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210926155310.png"></p>
<p>路由功能添加模糊匹配。 * 和#代表通配符。* 代表多个单词，#代表一个单词</p>
<h2 id="如何保证RabbitMQ消息的顺序性"><a href="#如何保证RabbitMQ消息的顺序性" class="headerlink" title="如何保证RabbitMQ消息的顺序性"></a>如何保证RabbitMQ消息的顺序性</h2><p>拆分多个queue，每个queue一个consumer，就是多一些queue而已</p>
<h2 id="消息如何分发"><a href="#消息如何分发" class="headerlink" title="消息如何分发"></a>消息如何分发</h2><p>​    若该队列至少有一个消费者订阅，消息将以循环的方式发送给消费者，每条消息只会分发给一个订阅的消费者，通过路由可实现多消费的功能</p>
<h2 id="消息怎么路由"><a href="#消息怎么路由" class="headerlink" title="消息怎么路由"></a>消息怎么路由</h2><p>​    在消息创建的时候，消息将拥有一个路由键，通过路由键可以把队列绑定到交换机上，消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配。</p>
<p>交换机主要分以下三种：</p>
<ul>
<li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</li>
<li>direct：如果路由键完全匹配，消息就被投递到相应的队列</li>
<li>topic：可以使来自不同源头的消息能够到达同一个队列，使用topic交换器时，可以使用通配符</li>
</ul>
<h2 id="消息基于什么传输"><a href="#消息基于什么传输" class="headerlink" title="消息基于什么传输"></a>消息基于什么传输</h2><p>​    由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据，信道是建立在真实的TCP连接内的虚拟连接，且每条TCP上的信道数量没有限制</p>
<h2 id="如何保证消息不被重复消费或者说如何保证幂等性"><a href="#如何保证消息不被重复消费或者说如何保证幂等性" class="headerlink" title="如何保证消息不被重复消费或者说如何保证幂等性"></a>如何保证消息不被重复消费或者说如何保证幂等性</h2><p>​    <strong>幂等性：用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong></p>
<p>​    正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。但是因为网络传输等故障，确认消息没有传到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</p>
<p>解决：</p>
<p>​    将写入队列的数据做一个唯一标识，每次消费消息时，根据唯一标识判断是否消费过。</p>
<h2 id="如何确保消息正确地发送至RabbitMQ-如何确保消息接收方消费了消息"><a href="#如何确保消息正确地发送至RabbitMQ-如何确保消息接收方消费了消息" class="headerlink" title="如何确保消息正确地发送至RabbitMQ?如何确保消息接收方消费了消息?"></a>如何确保消息正确地发送至RabbitMQ?如何确保消息接收方消费了消息?</h2><p>发送方确认模式：</p>
<ul>
<li>将信道设置成confirm模式，则所有在信道上发布的消息都会指派一个唯一的ID<ul>
<li>开启发布确认：channel.confirmSelect();</li>
</ul>
</li>
<li>一旦消息被投递到目的队列后，或者消息被写入磁盘后，信道会发送一个确认给生产者</li>
<li>如果RabbitMQ内部发生错误而导致消息丢失，会发送一条未确认消息</li>
</ul>
<p>消费方确认模式：</p>
<ul>
<li>消费者接收每一条消息都必须进行确认，只有确认之后RabbitMQ才会把消息删除</li>
</ul>
<h2 id="如何保证RabbitMQ消息的可靠传输"><a href="#如何保证RabbitMQ消息的可靠传输" class="headerlink" title="如何保证RabbitMQ消息的可靠传输"></a>如何保证RabbitMQ消息的可靠传输</h2><p>生产者方面：通过发送确认机制或者事务机制</p>
<ul>
<li><p>发送确认机制：将信道设置成confirm模式，则所有在信道上发布的消息都会指派一个唯一的ID，一旦消息被投递到匹配的队列之后，RabbitMQ会发送一个ACK给生产者，如果没有处理该消息，则会发送一个Nack消息</p>
</li>
<li><p>事务机制：发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现异常，事务就会回滚</p>
<p>  (channel.txRollback())，如果发送成功，则提交事务(channel.txCommit())。</p>
</li>
</ul>
<p>消息队列方面：</p>
<ul>
<li><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置，将durable 参数置为true即可</p>
<ul>
<li><pre class=" language-java"><code class="language-java">Queue<span class="token punctuation">.</span>DeclareOk <span class="token function">queueDeclare</span><span class="token punctuation">(</span>String queue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> durable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> exclusive<span class="token punctuation">,</span> <span class="token keyword">boolean</span> autoDelete<span class="token punctuation">,</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> arguments<span class="token punctuation">)</span>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>消费者方面：</p>
<ul>
<li><p>消费者丢失数据一般是因为采用了自动确认消息模式，改为手动就行了，具体如下</p>
<ul>
<li><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        Channel channel <span class="token operator">=</span> RabbitMQUtil<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C1等待接收处理消息，时间较短"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
        DeliverCallback deliverCallback <span class="token operator">=</span> <span class="token punctuation">(</span>consumerTag<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  
            <span class="token comment" spellcheck="true">//睡眠</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到的消息"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
            <span class="token comment" spellcheck="true">/**
             * 手动应答
             * 参数1：消息的标记 ；tag
             * 参数2：是否批量处理，fasle表示不批量
             */</span>
            channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
  
        CancelCallback cancelCallback <span class="token operator">=</span> consumerTag <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>TASK_QUEUE_NAME<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>deliverCallback<span class="token punctuation">,</span>cancelCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><p>RabbitMQ的镜像集群模式：</p>
<p>   在镜像集群模式下，创建的queue里的消息都会缓存在多个实例上，也就是每个RabbitMQ节点都有这个queue的一个完整镜像，包含全部数据，然后每次写消息到queue的时候，都会自动把消息同步到多个实例queue上</p>
<h2 id="生产者发送消息过程"><a href="#生产者发送消息过程" class="headerlink" title="生产者发送消息过程"></a>生产者发送消息过程</h2><ul>
<li>producer 先连接到Broker，建立连接Connection开启一个信道channel</li>
<li>声明一个交换机   channel.exchangeDeclare(EXCHANGE_NAME,”fanout”);</li>
<li>声明一个队列     channel.queueDeclare(“队列名称”, false, false, false, null);</li>
<li>绑定交换机和队列  channel.queueBind(“队列名称”,”交换机名称”,”路由名称”);</li>
<li>发送消息到交换机，再根据路由键查找队列</li>
<li>找到将消息存入对应的队列，如果没有找到，就<strong>丢弃或者退回给生产者</strong></li>
<li>关闭信道</li>
<li>关闭连接</li>
</ul>
<h2 id="消费者接收消息过程"><a href="#消费者接收消息过程" class="headerlink" title="消费者接收消息过程"></a>消费者接收消息过程</h2><ul>
<li>Consumer先连接到Broker，建立连接Connection开启一个信道</li>
<li>请求消费队列中的消息</li>
<li>消费者确认收到信息发送应答ack   channel.basicAck(message.getEnvelope().getDeliveryTag(),false); false表示不是批处理应答</li>
<li>RabbitMQ从队列中删除已经确定的消息</li>
<li>关闭信道</li>
<li>关闭连接</li>
</ul>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当消息在队里中变成死信之后，能重新被发送到另一个死信交换机中，绑定的队列就是死信队列</p>
<p>导致原因：</p>
<ul>
<li>消息被拒</li>
<li>队列已满</li>
<li>消息TTL过期</li>
</ul>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>​    存储对应的延迟消息，指当消息被发送以后，不想让消费者立即拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</p>
<h2 id="消费者无法处理当前接收的消息如何时决绝"><a href="#消费者无法处理当前接收的消息如何时决绝" class="headerlink" title="消费者无法处理当前接收的消息如何时决绝"></a>消费者无法处理当前接收的消息如何时决绝</h2><ul>
<li>channel.basicNack</li>
<li>channel.basicReject</li>
</ul>
<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">han77</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://han77520.github.io/2021/08/29/%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0/">http://han77520.github.io/2021/08/29/%E6%95%B4%E4%BD%93%E5%A4%8D%E4%B9%A0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">han77</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Tw1t1F755btODLVdHL3O30Xy-gzGzoHsz',
        appKey: 'kCKupgkz6MGJHgRBUMxT0ubD',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '想说点啥？Just go go ^_^'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/11/04/%E7%AE%97%E6%B3%95%E9%A2%98%E7%A7%AF%E7%B4%AF/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="算法题积累">
                        
                        <span class="card-title">算法题积累</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            算法题积累
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E7%A7%AF%E7%B4%AF/" class="post-category">
                                    算法题积累
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/08/14/SpringCloud/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="SpringCloud">
                        
                        <span class="card-title">SpringCloud</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            SpringCloud
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SpringCloud/" class="post-category">
                                    SpringCloud
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2735927705"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.3'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">瀚77</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">352.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/han77520" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1721616038@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://space.bilibili.com/406750122" class="tooltipped" target="_blank" data-tooltip="在B站上关注我" " data-position="top" data-delay="50">
        <i class="fas fa-play-circle"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1721616038" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1721616038" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://gitee.com/wang-hanwen/git-test1/blob/master/WeChat.PNG" class="tooltipped" target="_blank" data-tooltip="微信联系我: 15110606054" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>
    <script src="/"></script>
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
       

    <!--动态线条背景-->
<script type="text/javascript"
color="122 103 238" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<!-- 樱花-->
<!--<script type="text/javascript" src="/js/sakura.js"></script>-->

<!-- 雪花 -->
<!-- <script type="text/javascript" src="/js/snow.js"></script> -->

<!-- 趣味标题 -->
<script type="text/javascript" src="/js/Title.js"></script>

</body>

</html>
